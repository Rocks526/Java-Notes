# 一：二叉树

### 1.1 树的介绍

树是一种`非线性数据结构`，逻辑结构与现实中的树类似：

![image-20220328110035442](http://rocks526.top/lzx/image-20220328110035442.png)

这里面的每个元素称为`节点`，用来连线相邻节点之间的关系称为`父子关系`。

![image-20220328110150838](http://rocks526.top/lzx/image-20220328110150838.png)

如上图所示的树结构，A节点就是B节点的`父节点`，B节点是A节点的`子节点`。B、C、D这三个节点的父节点是同一个节点，所以它们之间互称为`兄弟节点`。我们把没有父节点的节点叫作`根节点`，也就是图中的节点E。我们把没有子节点的节点叫作`叶子节点或者叶节点`，比如图中的G、H、I、J、K、L都是叶子节点。

关于树，还有三个比较相似的概念：`高度（Height）`、`深度（Depth）`、`层（Level）`，它们的定义如下：

- 节点的高度：节点到叶子节点的最长路径(边数)
- 节点的深度：根节点到这个节点所经历的边的个数
- 节点的层数：节点的深度+1
- 树的高度：根节点的高度

![image-20220328111300654](http://rocks526.top/lzx/image-20220328111300654.png)

### 1.2 二叉树的介绍

树结构多种多样，不过最常用还是`二叉树`。顾名思义，二叉树要求每个节点最多有两个"叉"，也就是两个子节点，分别是`左子节点和右子节点`。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。

![image-20220328111453050](http://rocks526.top/lzx/image-20220328111453050.png)

上图中，有两个比较特殊的二叉树，分别是编号 2 和编号 3 这两个。

编号 2 的二叉树中，`叶子节点全都在最底层`，除了叶子节点之外，`每个节点都有左右两个子节点`，这种二叉树就叫作`满二叉树`。

编号 3 的二叉树中，`叶子节点都在最底下两层，最后一层的叶子节点都靠左排列`，并且除了最后一层，`其他层的节点个数都要达到最大`，这种二叉树叫作`完全二叉树`。

满二叉树很好理解，是一种非常特殊的二叉树，整个树结构很完整。而完全二叉树之所以单独区分，`主要是因为树的底层存储结构，当采用数组时，完全二叉树的空间占用率很高`，没有很多空隙。

### 1.3 二叉树的存储

想要存储一棵二叉树，一般有两种方法，一种是`基于引用的二叉链式存储法`，一种是`基于数组的顺序存储法`。

- 二叉链式存储法

链式存储法如图所示，每个节点有三个字段，`其中一个存储数据，另外两个是指向左右子节点的指针`。只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式比较常用，大部分二叉树代码都是通过这种结构来实现的。

![image-20220328112010868](http://rocks526.top/lzx/image-20220328112010868.png)

- 数组的顺序存储法

![image-20220328112339175](http://rocks526.top/lzx/image-20220328112339175.png)

基于数组的顺序存储法，`把根节点存储在下标 i = 1 的位置`，那`左子节点存储在下标 2 * i = 2 的位置`，`右子节点存储在 2 * i + 1 = 3 的位置`。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。

`如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点`。反过来，`下标为 i/2 的位置存储就是它的父节点`。通过这种方式，只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。

刚刚举的例子是一棵完全二叉树，所以仅仅浪费了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间，如下图所示：

![image-20220328112552109](http://rocks526.top/lzx/image-20220328112552109.png)

所以，`如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式`。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因。

### 1.4 二叉树的遍历

前面介绍了二叉树的基本定义和存储方法，现在来看二叉树中非常重要的操作，二叉树的遍历。

经典的方法有三种，`前序遍历、中序遍历和后序遍历`。 其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。

- 前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树
- 中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树
- 后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身

![image-20220328112927148](http://rocks526.top/lzx/image-20220328112927148.png)

`实际上，二叉树的前、中、后序遍历就是一个递归的过程`。比如前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。递推公式如下所示：

```shell
前序遍历的递推公式：
preOrder(r) = print r --> preOrder(r->left) --> preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left) --> print r -->inOrder(r->right)

后序遍历的递推公式：
postOrder(r) = postOrder(r->left) --> postOrder(r->right) --> print r
```

将递推公式转换为代码实现，如下：

```java
    /**
     * 先序遍历
     */
    public static String preOrder(Node<?> root){
        StringBuilder result = new StringBuilder();
        result.append("Tree<");
        preOrderInner(root, result);
        String substring = result.substring(0, result.length() - 1);
        return substring + ">";
    }

    private static void preOrderInner(Node<?> root, StringBuilder result) {
        if (root == null){
            return;
        }
        result.append(root.getValue()).append(",");
        preOrderInner(root.getLeft(), result);
        preOrderInner(root.getRight(), result);
    }

    /**
     * 中序遍历
     */
    public static String inOrder(Node<?> root){
        StringBuilder result = new StringBuilder();
        result.append("Tree<");
        inOrderInner(root, result);
        String substring = result.substring(0, result.length() - 1);
        return substring + ">";
    }

    private static void inOrderInner(Node<?> root, StringBuilder result) {
        if (root == null){
            return;
        }
        inOrderInner(root.getLeft(), result);
        result.append(root.getValue()).append(",");
        inOrderInner(root.getRight(), result);
    }

    /**
     * 后序遍历
     */
    public static String postOrder(Node<?> root){
        StringBuilder result = new StringBuilder();
        result.append("Tree<");
        postOrderInner(root, result);
        String substring = result.substring(0, result.length() - 1);
        return substring + ">";
    }

    private static void postOrderInner(Node<?> root, StringBuilder result) {
        if (root == null){
            return;
        }
        postOrderInner(root.getLeft(), result);
        postOrderInner(root.getRight(), result);
        result.append(root.getValue()).append(",");
    }
```

在遍历的过程中，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说`二叉树遍历的时间复杂度是O(n)`。

### 1.5 二叉树的层次遍历

```java
    /**
     * 层次遍历
     */
    public static String levelOrder(Node<?> root){
        StringBuilder result = new StringBuilder();
        result.append("Tree<");
        ArrayBlockingQueue<Node<?>> queue = new ArrayBlockingQueue<>(Integer.MAX_VALUE);
        queue.add(root);
        while (!queue.isEmpty()){
            Node<?> node = queue.poll();
            result.append(node.getValue()).append(",");
            if (node.getLeft() != null){
                queue.add(node.getLeft());
            }
            if (node.getRight() != null){
                queue.add(node.getRight());
            }
        }
        String substring = result.substring(0, result.length() - 1);
        return substring + ">";
    }
```

# 二：二叉查找树

### 2.1 二叉查找树的介绍

二叉查找树是二叉树中最常用的一种类型，也叫`二叉搜索树`。顾名思义，`二叉查找树是为了实现快速查找而生的`。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。

二叉查找树之所以能做到快速的增删改查，`依赖于二叉查找树的特殊结构`。二叉查找树要求，在树中的任意一个节点，`其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值`。如下图所示：

![image-20220328143712538](http://rocks526.top/lzx/image-20220328143712538.png)

### 2.2 二叉查找树的查询

二叉树查找树的查询操作比较简单，由于左子树 < 根节点 < 右子树的特性，`查询时只需要先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找`。

![image-20220328143948895](http://rocks526.top/lzx/image-20220328143948895.png)

### 2.3 二叉查找树的插入

二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以只需要从根节点开始，依次比较要插入的数据和节点的大小关系。

- 如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置
- 如果右子树不为空，就再递归遍历右子树，查找插入位置
- 同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置，如果不为空，就再递归遍历左子树，查找插入位置

![image-20220328144601535](http://rocks526.top/lzx/image-20220328144601535.png)

### 2.4 二叉查找树的删除

二叉查找树的查找、插入操作都比较简单易懂，但是它的删除操作比较复杂。针对要删除节点的子节点个数的不同，需要分三种情况来处理：

- 如果要删除的节点没有子节点，只需要直接将父节点中指向要删除节点的指针置为null，例如下图中的删除节点55
- 如果要删除的节点只有一个子节点，只需要更新父节点中指向要删除节点的指针，让它指向要删除节点的子节点就可以了，例如图中的删除节点13
- 如果要删除的节点有两个子节点，就比较复杂，需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上，然后再删除掉这个最小节点（由于最小节点肯定没有左子节点，所以我们可以应用上面两条规则来删除这个最小节点，例如图中的删除节点18）

![image-20220328145812474](http://rocks526.top/lzx/image-20220328145812474.png)

关于二叉查找树的删除操作，还有个简单、取巧的方法，就是单纯将要删除的节点标记为"已删除"，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。

### 2.5 二叉查找树的其他操作

除了插入、删除、查找操作之外，二叉查找树中还可以支持`快速地查找最大节点和最小节点、前驱节点和后继节点`。

还有一个重要的特性，就是`中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)`，非常高效。因此，二叉查找树也叫作二叉排序树。

### 2.6 支持重复数据的二叉查找树

在上面的示例中，数据都是不重复的，当存在重复数据时，需要进行特殊处理，一般方式有两种：

- 通过动态数据结构，将相同大小的节点存储成一个集合

二叉查找树中每一个节点不仅会存储一个数据，因此通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。这种实现方式比较简单。

- 插入时将相同大小的值当做大于处理

每个节点仍然只存储一个数据，在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。

![image-20220328151511819](http://rocks526.top/lzx/image-20220328151511819.png)

当要查找数据的时候，遇到值相同的节点，并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点才停止。这样就可以把键值等于要查找值的所有节点都找出来。

![image-20220328151521201](http://rocks526.top/lzx/image-20220328151521201.png)

对于删除操作，也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法依次删除。

![image-20220328151530606](http://rocks526.top/lzx/image-20220328151530606.png)

### 2.7 二叉查找树的时间复杂度

二叉查找树的形态各式各样，例如下图中的几个二叉树，都是同样的数据，但时间复杂度完全不一样。

![image-20220328152013727](http://rocks526.top/lzx/image-20220328152013727.png)

图中左侧的二叉树，由于根节点的左右子树极度不平衡，`已经退化成了链表，所以查找的时间复杂度就变成了 O(n)`。

右侧的二叉树是完全二叉树，分布就比较均衡，时间复杂度和树的高度成正比。`而完全二叉树的层数小于等于logN+1，也就是说，完全二叉树的高度小于等于 logN，插入、删除、查找等操作的时间复杂度也就是O(logN)`。

这些左右子树高度比较平衡的二叉树也叫平衡二叉树，`平衡二叉查找树的高度接近 logN，所以插入、删除、查找操作的时间复杂度也比较稳定，是O(logn)`，也是我们构建树的目标。

### 2.8 二叉查找树和哈希表的对比

之前介绍过散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度也是 O(logn)，相对散列表并没有优势，之所以工程实现上常用二叉树的原因有以下几点：

- 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，只需要中序遍历，就可以在 O(n) 的时间复杂度内输出有序序列
- 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，而在在工程中常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在O(logn)
- 散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快，加上哈 希函数的耗时，也不一定就比平衡二叉查找树的效率高
- 散列表的构造比二叉查找树要复杂，需要考虑的东西很多，比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案也比较成熟、固定
- 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，因此会浪费一定的存储空间

# 三：红黑树

### 3.1 平衡二叉查找树介绍







### 3.2 红黑树介绍



### 3.3 红黑树的实现





### 3.4 红黑树的插入操作





### 3.5 红黑树的删除操作











# 四：递归树

### 4.1 递归树介绍



### 4.2 快排时间复杂度分析



### 4.3 斐波那契数列的时间复杂度分析





### 4.4 全排列的时间复杂度分析







# 五：LeetCode







