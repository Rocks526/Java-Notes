# 一：小顶堆实现方案

### 1.1 小顶堆介绍

**堆结构介绍**

堆是一种特殊的`完全二叉树`，如果所有父节点都大于子节点则成为大顶堆，反之为小顶堆。

<img src="http://rocks526.top/lzx/image-20210326170937266.png" alt="image-20210326170937266" style="zoom: 67%;" />

上图所示即为一个小顶堆，他具备如下特点：

- 是一个完全二叉树
- 叶子节点从左往右排列
- 堆顶元素为整个树的最小值

堆是一个逻辑结构，其底层实现的物理结构一般采用数组实现：

- 空出数组的第一个元素，从数组下标为1的地方开始存储元素
- 存储顺序从上到下，从左往右

利用数组存储，父节点的位置总是子节点下标/2，通过O(1)即可拿到父节点。

<img src="http://rocks526.top/lzx/image-20210326171544156.png" alt="image-20210326171544156" style="zoom:67%;" />

**入堆**

入堆的流程：

- 新添加的元素放到堆尾
- 新加入的元素反复和父节点对比，如果小于父节点则和父节点交换位置，直到大于父节点
- 由于底层数组存储，子节点找父节点时间复杂度为O(1)，因此入堆的时间复杂度为O(lgn)

<img src="C:\Users\lizhaoxuan\AppData\Roaming\Typora\typora-user-images\image-20210326172730197.png" alt="image-20210326172730197" style="zoom:80%;" />

**出堆**

出堆的流程：

- 每次出堆是堆顶元素，即最小值
- 堆顶出堆之后，将最末尾的元素放到堆顶
- 将堆顶元素与两个子节点对比，与最小的一个交换，反复下沉直到小于两个子节点
- 由于底层采用数组存储，父节点获取子节点的时间复杂度O(1)，因此出堆的时间复杂度O(lgn)

<img src="http://rocks526.top/lzx/image-20210326173438649.png" alt="image-20210326173438649" style="zoom:80%;" />

### 1.2 通过小顶堆实现定时任务

- 通过小顶堆存储所有提交的定时任务，节点的大小根据定时任务的下次执行时间进行比较，距离下次执行时间最近的任务是堆顶元素。

- 通过一个调度线程不断检查堆顶元素和当前时间，如果时间到达，则取出堆顶元素执行任务并等待下一次堆顶元素的时间到达。
- 如果时间没有到达，进入死循环，也可以阻塞等待。

### 1.3 小顶堆方案存在的问题

- 每次取出，都需要进行下沉操作，即使复杂度为logN，但当堆特别大时，性能会降低
- 在定时任务的业务场景上，只关心最近执行的任务，只需要取出最近执行任务即可，但由于小顶堆需要维护数据结构，需要不断下沉，这些下沉操作是多余的性能开销
- 因此小顶堆比较适合少量的定时任务存储，当有几万几十万定时任务时，定时任务的执行又很频繁，会导致不断的进行取出，堆下沉操作。

# 二：时间轮算法

### 1.1 简易时间轮

**时间轮介绍**

<img src="http://rocks526.top/lzx/image-20210326180553734.png" alt="image-20210326180553734" style="zoom:67%;" />

时间论的原理如上图所示，和钟表一样划分为12个时间段，每个时间段只存储该时间段内触发的定时任务，这样当某个时刻到达时，只需要遍历取出所有任务进行执行即可。

时间轮的优点在于不需要遍历所有的定时任务，只需要遍历该时间段的任务即可，而且任务执行只需要取出任务即可，无需和小顶堆一样进行下沉操作来维护小顶堆的数据结构。

**存储结构**

12个时间片段可以采用长度为12的数组存储，每个时间片段内的定时任务可以采用链表存储。

**存在的问题**

- 时间刻度只有12，人可以区分1点和13点，程序如何区分？
- 定时任务不只是一天的，如果一个定时任务是2号的3点，一个是3号的3点，如何存储？

> 第一个问题：时间轮改为24刻度即可解决。
>
> 第二个问题：为了存储不同天的任务，需要再添加一个天级别的时间轮，30个分片，那么对于不同月和年的定时任务，也需要加对应的时间轮，最终导致实现很繁琐。
>
> 对于第二个问题的解决方案，可以采用round时间轮。

### 1.2 round型时间轮

**round时间轮介绍**

为了解决不同时间轮回的同一时刻的问题，给任务新增一个round字段，用round来存储轮回次数，每过一轮round减一。

例如：区分13点和1点，都属于1刻度区域，1点的任务round值为0，13点的任务round为1，当时间到达1点时，将所有任务取出，执行所有round为0的任务，其他任务round减一，如此即可解决多次轮回同一时刻的问题。

**存在的问题**

- round时间轮看上去很完美，解决了多次轮回同一时刻的问题，但由于每次到达时刻都需要遍历所有任务将round减一，因此一些不需要执行的任务也需要遍历，导致大量多余的遍历操作，影响性能。
- 如果某个任务1年后执行，那么round时间轮还是会每12h遍历一次，将round减一，显得过于笨重。

### 1.3 分层时间轮

**分层时间轮介绍**

分层时间轮是round时间轮和之前提到的多个时间轮的综合方案，也是目前采用最广泛的方案，例如linux的cron/Quartz/Elastic-job等都采用此方案。

以两层时间轮为例：一层天轮，一层月轮，天轮存储24个时间片，代表一天的24时，月轮存储30个时间片，代表一个月，当第二天到达时，先将月轮对应的那一天的定时任务全部取出放到天轮里，然后天轮执行。

维护多个时间轮，到达指定时间后，将外轮的数据放入内轮，对内轮进行遍历即可减少round时间轮的大量无用遍历操作。

> 两层时间轮可以记录一个月的所有时间，如果需要记录下个月甚至下一年，可以继续加一层时间轮或者外轮采用round方式。



