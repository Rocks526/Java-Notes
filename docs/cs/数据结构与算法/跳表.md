# 一：跳表的介绍

### 1.1 跳表的介绍

在介绍二分查找算法时提过，因为二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，由于访问元素的时间复杂度是O(N)，查找效率会大幅度降低。

实际上，我们只需要对链表稍加改造，就可以支持类似"二分"的查找算法。我们把改造之后的数据结构叫作跳表(Skip List)。

跳表是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树。Redis 中的有序集合（Sorted Set）就是用跳表来实现的。

### 1.2 跳表的由来

对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是O(n)。

![image-20220324102954707](http://rocks526.top/lzx/image-20220324102954707.png)

为了提高查询效率，可以对链表建立一级"索引"。每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引或索引层， 使用 down 指针，指向下一级结点。

![image-20220324103330581](http://rocks526.top/lzx/image-20220324103330581.png)

现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。

加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了，当链表足够大时，加了多层索引后，查询效率就会极大的提升。

![image-20220324103448815](http://rocks526.top/lzx/image-20220324103448815.png)

`这种链表加多级索引的结构，就是跳表`。

### 1.3 跳表的时间复杂度

在一个单链表中查询某个数据的时间复杂度是 O(n)，那在一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少呢？

按照刚才介绍的，每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，`第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2^k)`。

假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2^h)=2， 从而求得 h=logn-1。如果包含原始链表这一层，整个跳表的高度就是 log n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，`那在跳表中查询一个数据的时间复杂度就是 O(m*logn)`。这个查找的时间复杂度跟二分查找是一样的，`我们其实是通过建立多级索引的方式，基于单链表实现了二分查找`，这其实也是一种空间换时间的思路。

### 1.4 跳表的空间复杂度

- 比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间，那么他的空间复杂度是多少？

假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到 剩下 2 个结点。很明显这是一个等比数列，这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。`所以跳表的空间复杂度是 O(n)`。

- 那么有没有办法减少跳表的空间浪费？

我们前面都是每两个结点抽一个结点到上级索引，如果我们每三个结点或五个结点，抽一个结点到上级索引，则可以大幅度降低空间的消耗，对应的查询效率也会降低。因此，跳表可以通过索引的组建策略，灵活的调整空间消耗和查询效率之间的平衡。

- 工程实践

实际上，在软件开发中，我们不必太在意索引占用的额外空间。因为原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，`所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了`。

### 1.5 跳表的插入与删除

跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，`而且插入、删除操作的时间复杂度也是 O(logn)`。

- 插入操作

在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，是O(1)。但是，这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，查找某个结点的的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(logn)。

- 删除操作

如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。 因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。这个可以通过双链表实现O(1)获取前驱节点。因此，删除操作的时间复杂度也是查找待删除节点的O(logn)+删除的O(1)。

- 索引的动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

![image-20220324104816703](http://rocks526.top/lzx/image-20220324104816703.png)

作为一种动态数据结构，`我们需要某种手段来维护索引与原始链表大小之间的平衡`，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。

红黑树、AVL 树这样平衡二叉树，它们是通过左右旋的方式保持左右子树的大小平衡，而跳表是`通过随机函数`来维护前面提到的"平衡性"。

当我们往跳表中插入数据的时候，`我们可以选择同时将这个数据插入到部分索引层中`。如何选择加入哪些索引层呢？

我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。

![image-20220324104957780](http://rocks526.top/lzx/image-20220324104957780.png)

`可以通过设计优秀的随机函数，实现跳表的索引大小和数据大小平衡性`，不至于性能过度退化。

### 1.6 跳表与红黑树对比

- 查询、插入、删除等操作的时间复杂度，红黑树和跳表都可以做到O(logn)
- 按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，红黑树相对就没这么高效
- 跳表相比红黑树实现更为简单，而且更加灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗
- 红黑树的操作时间复杂度非常稳定，都是O(logn)，而跳表可能极端情况下会退化为单链表的O(n)
- 红黑树出现比跳表更早，主流语言基本都有内置实现

# 二：跳表的实现



