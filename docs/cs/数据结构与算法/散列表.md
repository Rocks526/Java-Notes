# 一：散列表介绍

### 1.1 散列思想

`散列表用的是数组支持按照下标随机访问数据的特性`，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

举个例子：假如有 89 名选手参加学校运动会，为了方便记录成绩，每个选手胸前都会贴上自己的参赛号码。这 89 名选手的编号依次是 1 到 89。现在`希望通过编号快速找到对应的选手信息`，可以把这 89 名选手的信息放在数组里。编号为 1 的选手，我们放到数组中下标为 1 的位置；编号为 2 的选手，我们放到数组中下标为 2 的位置。以此类推，编号为 k 的选手 放到数组中下标为 k 的位置。因为参赛编号跟数组下标一一对应，当我们需要查询参赛编号为 x 的选手的时候，我们只需要将下标为 x 的数组元素取出来就可以了，时间复杂度就是 O(1)。

这就是典型的散列思想。其中，参赛选手的编号我们叫作`键`，我们用它来标识一个选手。把参赛编号转化为数组下标的映射方法就叫作`散列函数`，而散列函数计算得到的值就叫作`散列值`。

总结一下：`散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据`。

### 1.2 散列函数

散列函数，顾名思义，它是一个函数。我们可以把它定义成hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。散列函数设计有如下基本要求：

- 散列函数计算得到的散列值是一个非负整数
- 如果 key1 = key2，那 hash(key1) == hash(key2)
- 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)

第三个要求看起来合情合理，但是在真实的情况下，`要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的`。即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种`散列冲突`。而且，因为数组的存储空间有限，也会加大散列冲突的概率。

所以几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，`我们需要通过其他途径来解决`。

### 1.3 散列冲突

再好的散列函数也无法避免散列冲突，我们常用的散列冲突解决方法有两类，`开放寻址法和链表法`。

- 开放寻址法

开放寻址法的核心思想是，`如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入`。那如何重新探测新的位置呢？方式有很多，常用的有`线性探测、二次探测、双重散列`的。

线性探测：当存在冲突时，顺序遍历后面的位置，找到一个空位插入即可。

二次探测：当存在冲突时，和线性探测一样继续往后查找空位，只是每次都是以2^n方式跳着查。

双重散列：使用一组多个散列函数，当存在冲突时，使用其他散列函数再次查找。

不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。 为了尽可能保证散列表的操作效率，一般情况下，`我们会尽可能保证散列表中有一定比例的空闲槽位`。我们用`装载因子（load factor）`来表示空位的多少。

```shell
散列表的装载因子 = 填入表中的元素个数 / 散列表的长度
```

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

- 链表法

链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。如下图所示，在散列表中，每个"桶"会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。

![image-20220324155009410](http://rocks526.top/lzx/image-20220324155009410.png)

当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以`插入的时间复杂度是 O(1)`。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。`查找或删除操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)`。

### 1.4 散列表与链表的组合

在软件开发中，散列表经常和链表组合使用，例如Redis的Sorted Set和Java的LinkedHashMap，这个链表指的不是通过链表法解决散列冲突，而是`通过一个链表将散列表的所有Key根据某种顺序串起来，实现Key的排序`。

# 二：设计工业级散列表

### 2.1 散列表的碰撞攻击

散列表的查询效率并不能笼统地说成是 O(1)，它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。

在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。这样就有可能因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，`从而达到拒绝服务攻击 （DoS）的目的。这也就是散列表碰撞攻击的基本原理`。

如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？

- 设计一个合适的散列函数
- 定义装载因子阈值，并且设计动态扩容策略
- 选择合适的散列冲突解决方法

### 2.2 散列函数的设计

散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。那什么才是好的散列函数呢？

- 散列函数的设计不能太复杂

过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能。

- 散列函数生成的值要尽可能随机并且均匀分布

这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。

- 还需要综合考虑各种因素

这些因素包括元素的长度、特点、分布、还有散列表的大小等。

- 散列函数设计方法

散列函数的设计方法有很多，比如`直接寻址法、平方取中法、折叠法、随机数法`等，需要根据场景选择合适的方法。

### 2.3 动态扩容策略

- 扩容机制

之前提到散列表的装载因子的时候说过，`装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大`。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。

对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，对于动态散列表来说，数据集合是频繁变动的，`我们事先无法预估将要加入的数据个数`，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到不可接受的程度时，就需要`动态扩容`来提升操作效率。

针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。`因为散列表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置`。

- 高效扩容

对于支持扩容机制的散列表，插入时间复杂度在正常情况下都是O(1)，在容量不足扩容时由于需要搬移所有元素，因此是O(N)。根据摊还分析法，N次插入会有一次扩容，因此`平均时间复杂度是 O(1)`。

大部分情况下，动态扩容的散列表插入一个数据都很快，但是在特殊情况下，当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。例如一个1G的散列表，扩容为2G，扩容的那次插入操作就会特别慢。

为了解决一次性扩容耗时过多的情况，`我们可以将扩容操作穿插在插入操作的过程中，分批完成`。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。这期间的查询操作为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。

`通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中`，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。

### 2.4 散列冲突的解决

之前介绍了两种主要的散列冲突的解决办法，开放寻址法和链表法。这两种冲突解决办法在实际的软件开发中都非常常用。比如， LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。

- 开放寻址法

开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以`有效地利用 CPU 缓存`加快查询速度。而且，这种方法实现的散列表，`序列化起来比较简单`。

用开放寻址法解决冲突的散列表，`删除数据的时候比较麻烦`，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，`冲突的代价更高`。所以，使用开放寻址法解决冲突的散列表，`装载因子的上限不能太大`。这也导致这种方法比链表法更浪费内存空间。

因此，`当数据量比较小、装载因子小的时候，适合采用开放寻址法`。

- 链表法

`链表法对内存的利用率比开放寻址法要高`。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。

`链表法比起开放寻址法，对大装载因子的容忍度更高`。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。

其次，对链表法稍加改造，可以实现一个更加高效的散列表。那就是，`将链表法中的链表改造为其他高效的动态数据结构`，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过 是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。

因此，`基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表`，而且，比起开放寻址法，它`更加灵活，支持更多的优化策略`，比如用红黑树代替链表。

# 三：散列表的实现

- 代码实现

```java

```

- 单元测试

```java

```





