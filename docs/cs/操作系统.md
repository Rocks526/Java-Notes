- [操作系统概述](#gs)
- [进程管理](#jc)
- [内存管理](#nc)
- [文件管理](#wj)
- [IO管理](#io)

# <a id="gs">操作系统概述</a>

**计算机的层次结构**

![image-20200502174302450](C:\Users\67409\AppData\Roaming\Typora\typora-user-images\image-20200502174302450.png)

计算机的层次结构如上图所示：

- 最底层是CPU，内存等硬件资源设备
- 在硬件的基础上是操作系统，操作系统负责硬件的控制和管理，并提供给用户好用的接口和环境
- 在操作系统之上是应用程序，应用程序基于操作系统提供的接口，申请使用计算机的资源为用户提供不同的服务，一般都会提供GUI操作界面
- 最上层就是用户，通过操作系统和应用程序两层封装，用户可以很容易的使用计算机的资源；用户同样可以通过Shell接口和操作系统直接交互，操作计算机

**操作系统的概念**

操作系统是指：

- 控制和管理整个计算机系统的硬件和软件资源
- 并合理的组织调度计算机的工作和资源分配
- 以提供给用户和其他软件方便的接口和环境
- 它是计算机系统里最基本的系统软件

**总结：**操作系统本质上是作为一个计算机的管理者，替用户实现处理机，存储器，文件和设备等资源的管理，并为用户封装底层的硬件操作，提供给用户简单的操作接口

操作系统为用户提供的操作接口有：

- 普通用户接口
  - GUI界面：Windows，Android等
  - 命令接口
    - 联机命令接口：cmd窗口的shell命令
    - 脱机命令接口：bat批处理命令

- 软件开发者接口
  - 程序接口：在程序中通过系统调用使用程序接口

**操作系统的特征**

操作系统有**并发，共享，虚拟，异步**四大特征，其中并发和共享是操作系统最基本的特征

- 并发

> 并发是多个事件在同一时间间隔内发生，宏观上是同时发生，微观上是交替发生
>
> 区别于并行，并行是多个事件同一时刻发生，并行只有在多核处理器才能出现
>
> 操作系统的并发性是指计算机系统中同时运行着多个程序，这些程序宏观上看是共同运行的，微观上是交替运行的
>
> 操作系统是伴随着"多道程序技术"一起出现的，并发是操作系统的一个基本特征

- 共享

> 共享是指操作系统管理的资源共享，即操作系统中的资源可供内存中多个并发执行的进程共同使用
>
> 共享可分为互斥共享和同时共享两种

- 虚拟

> 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物
>
> 虚拟分为空分复用技术(虚拟存储器技术)和时分复用技术(虚拟处理器)

- 异步

> 异步是指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行是走走停停，以不可预知的速度向前推进

**操作系统的发展和分类**

- 手工操作阶段

> 此时还没有操作系统，用户通过打孔的纸带向计算机录入数据，计算机运行完成后再输出数据，计算机计算速度非常快，但用户录入和取出数据的速度非常慢
>
> 缺点：用户独占计算机，人机速度矛盾导致计算机资源利用率低下

- 批处理阶段 —— 单道批处理系统

> 引入脱机输入/脱机输出技术，并有监督程序控制作业的输入和输出，通过外围机读取多个输入设备的纸带数据，并将数据存储进磁带，再由监督程序从磁带读出数据给计算机进程处理，磁带的读取速度比纸带快很多
>
> 优点：缓解了一定人机矛盾，可以批处理多人任务，资源利用率提升
>
> 缺点：内存中仅有一道程序，只有该程序结束后才能进行下一道程序，CPU有大量的空闲时间等待IO操作

- 批处理阶段 —— 多道批处理系统

> 每次从磁带读取多道程序，在计算机中并发运行，为了解决并发运行多个程序的问题，发明了操作系统
>
> 优点：多道程序并发执行，共享计算机资源，资源利用率大幅度提升，系统吞吐量增大
>
> 缺点：没有人机交互，用户响应时间长，无法debug，修改输入参数等

- 分时操作系统

> 计算机以时间片为单位轮流给各个用户/程序服务，各个用户通过终端和计算机交互
>
> 优点：用户请求可以被立即响应，解决人机交互问题
>
> 缺点：不能优先处理一个紧急任务，操作系统对所有用户/程序完全公平

- 实时操作系统

> 优点：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队
>
> 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件
>
> 主要特点是实时性和可靠性
>
> 实时操作系统分为硬实时系统(必须在绝对严格的规定时间内完成处理，如导弹控制系统，自动驾驶系统等)和软实时系统(允许偶尔违反规定事件)

- 其他操作系统介绍
  - 网络操作系统：伴随着计算机网络的发展而诞生的，能把网络中的各个计算机有效的连接起来，实现数据传输等功能
  - 分布式操作系统：主要特点是分布式和并行性，系统中的多台计算机地位相同，任何工作都可以分布在这些计算机上，由这些计算机并行，协同完成
  - 个人操作系统：如Windows XP，MacOS等，适合个人使用

**操作系统的运行环境**

应用程序分为两种：

- 应用程序：基于操作系统的接口编写的程序，给用户提供服务，不能执行一些可能危害计算机的特权指令
- 内核程序：管理计算机的程序，可以执行一些危险的特权指令

CPU在设计和生产的时候就划分了特权指令和非特权指令，为了让CPU区分执行特权指令的是内核程序还是应用程序，操作系统将运行空间划分为内核态和用户态，CPU中的程序状态字寄存器(PSW)有一个二进制位，为1表示内核态，为0表示用户态

- 处于内核态时，说明运行的是内核程序，可以使用特权指令
- 处于用户态时，说明运行的是应用程序，只能执行非特权执行

操作系统在内核态和用户态之间的转换：

> - 刚开机时，CPU为内核态，操作系统的内核程序先上CPU运行，检查硬件资源，启动操作系统
>
> - 开机完成后，用户启动某个应用程序，操作系统内核程序让出CPU，让应用程序在CPU运行，切换到用户态
> - 当应用程序中存在特权指令时，CPU发现特权指令，而此时是用户态，CPU会产生一个中断信号
> - 中断信号让应用程序停止运行，操作系统内核程序重新拿到CPU控制权，对引发中断的事件进行处理，处理完成后再把CPU使用权交还应用程序

- 内核态 -> 用户态：执行一条特权指令，修改PSW标志位为0，切换用户态，主动让出CPU使用权
- 用户态 -> 内核态：由中断信号引发，硬件自动完成状态切换

> 中断介绍
>
> 中断的作用：让内核程序重新拿回CPU控制权
>
> 中断类型
>
> - 内中断：与当前执行的指令有关，中断信息来自于CPU内部
>   - 特权指令
>   - 除数为0等参数异常
>   - 陷入指令(应用程序想请求操作系统的系统内核服务，通过主动调用陷入指令将CPU控制权交给系统内核，如系统调用等)
> - 外中断：与当前执行的指令无关，中断信号来自CPU外部
>   - 时钟中断：时钟部件发出的中断信号
>   - IO中断：IO设备处理完成后发送中断信号，请求操作系统处理
>
> 内中断也成为异常，常分为三种：
>
> - 陷阱、陷入：陷入指令引发，程序故意引发请求操作系统服务
> - 故障：由错误条件引起，可能被内核修复。内核程序修复故障后将CPU使用权还给应用程序，如缺页故障
> - 终止：由致命错误引起，内核程序无法修复，不会将使用权还给应用程序，而是直接终止该程序的运行。如非法特权指令，除数为0等
>
> 中断机制的原理：
>
> 不同的中断信号，需要不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询"中断向量表"，以此来找到对应的中断处理程序在内存中的存放位置。

**操作系统的体系结构**

内核是操作系统最基本、最核心的部分，实现操作系统内核功能的那些程序就是内核程序

内核核心功能：

- 时钟管理
- 中断处理
- 原语
- 资源管理
  - 进程管理
  - 存储器管理
  - 设备管理

操作系统的体系结构可以分为：大内核和微内核。

**大内核**

操作系统的主要功能模块(包含资源管理，GUI等)都包含在内核里

- 优点
  - 性能高，资源管理功能在内核里，属于内核态，程序系统请求时只需要两次变态，而微内核由于资源管理功能在用户态，需要多次变态，频繁的变态会降低系统性能

- 缺点
  - 内核代码庞大，结构混乱，难以维护
- 常见操作系统
  - Linux，Unix

**微内核**

只将最核心功能包含在内核里

- 优点
  - 内核功能少，结构清晰，维护简单
- 缺点
  - 需要频繁在用户态和内核态之间切换

- 常见操作系统
  - Windows NT

# <a id="jc">进程管理</a>

### 进程基础

**进程的概念**

- 程序是静态的，是存放再磁盘的可执行文件，一系列指令的集合

- 进程是动态的，是程序的一次执行过程
- 进程是程序的运行过程，是系统进行资源分配和调度的一个独立单位
- 线程是在进程的基础上提出的，为了提高系统的并发性，在进程内部划分多个线程，共享进程资源，线程是调度的基本单位

**进程的组成**

进程的组成主要包括三部分：**PCB，程序段和数据段**

操作系统需要对各个并发运行的进程进行管理，需要给各个进程创建一个维护管理信息的数据结构——PCB(Process Control Block)，即进程控制块，进程结束时操作系统会回收其PCB。PCB主要包含以下信息：

- 标识进程唯一性的PID，标识用户的UID
- 记录给进程分配的资源(如内存，IO，文件等)
- 记录进程的运行情况(如CPU使用时间，磁盘使用情况，网络流量使用情况等)
- 处理机相关信息，如PSW，PC等各种寄存器信息

程序段指的是需要执行的程序的代码(指令的序列集合)

数据段指的是运行过程中产生的各种数据(如程序中定义的变量等)

**进程的特征**

- 动态性：进程是程序的一次执行过程，是动态的、变化的
- 并发性：内存中有多个进程实体，各进程可并发执行
- 独立性：进程是能独立运行，独立获得资源，接受调度的基本单位
- 异步性：各进程按各自单位独立运行，以不可预知的速度向前推进，操作系统要提供"进程同步机制"来解决异步问题，协调进程同步工作
- 结构性：每个进程都会分配一个PCB，结构上看，进程由程序段和数据段，PCB组成

### 进程的状态与转换

**进程状态**

- 创建态：程序要执行，从硬盘调入内存，操作系统创建进程，分配资源，初始化PCB
- 就绪态：操作系统为进程分配好资源，初始化完成PCB等信息，达到了运行条件，但是还未拿到CPU时间片
- 运行态：进程正在CPU上运行
- 阻塞态：进程运行过程中，请求某种资源无法满足或者等待其他进程响应导致无法继续运行，此时会让出CPU使用权，进入阻塞态，当条件满足后重新进入就绪态
- 终止态：进程运行结束，执行exit系统调用，请求操作系统终止进程，此时进入终止态，操作系统回收各种资源

**状态间的转换**

![image-20200503100343097](C:\Users\67409\AppData\Roaming\Typora\typora-user-images\image-20200503100343097.png)

**进程的组织方式**

进程的PCB中有一个state变量来表示进程状态，为了对同一状态下的进程统一管理，操作系统会将进程组织起来

进程的组织方式有两种：链式方式和索引方式

- 链式方式：操作系统维护多个指针，如运行指针，就绪队列指针，阻塞队列指针等，对应状态的进程挂在指针之后，形成链表(通常会将优先级较高的进程放在队头)，有些操作系统会将阻塞队列分为多个，如等待打印机，等待磁盘IO等
- 索引方式：操作系统维护多个状态表，如运行状态表，就绪状态表等，表里存放各个进程位置的指针

> 多数操作系统都采用链式的方式

### 进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现进程状态转换等功能

进程的控制由"原语"实现

> 原语是一种特殊的程序，它的执行具有原子性，不可中断。
>
> 一般由操作系统内核提供，通过关中断指令和开中断指令实现原子性

**创建原语**

操作系统创建进程的原语步骤：

- 申请空白PCB
- 为新进程分配所需资源
- 初始化PCB
- 将PCB插入就绪队列

操作系统创建进程条件：

- 用户登录：分时系统中，用户登陆成功，系统会为其建立一个新的进程
- 作业调度：多道批处理系统中，有新的作业调入内存
- 提供服务：用户向操作系统提出某些需求时
- 应用请求：用户进程主动请求创建一个进程

**撤销原语**

操作系统撤销进程的原语步骤：

- 从PCB集合中找到终止进程的PCB
- 若进程正在运行，立即剥夺CPU，将CPU使用权让出
- 终止所有子进程
- 将占有的资源归还
- 删除PCB

操作系统撤销进程的条件：

- 进程正常结束
- 进程异常结束
- 外界干预(如kill -9强杀进程)

**阻塞原语**

操作系统阻塞进程的原语步骤：

- 找到要阻塞的进程的PCB
- 保护进程现场，将PCB状态信息修改为阻塞态，暂停进程运行
- 将PCB插入对应事件的等待队列

操作系统阻塞进程的条件：

- 需要等待操作系统分配某种资源
- 需要等待相互合作的其他进程响应

**唤醒原语**

操作系统唤醒进程的原语步骤：

- 在等待事件队列中找到PCB
- 将PCB从等待队列中移除，设置进程为就绪态
- 将PCB插入就绪队列，等待调度

操作系统唤醒进程的条件：

- 等待的事件发生
  - 资源满足
  - 其他进程响应等

**进程切换原语**

操作系统进程切换原语步骤：

- 将运行环境存入PCB
- PCB移入相应队列
- 选择另一个进程执行，并更新其PCB
- 根据PCB恢复新进程所需的运行环境

操作系统进程切换的条件：

- 时间片到达
- 更高优先级进程
- 当前进程阻塞
- 当前进程终止

### 进程通信

进程是资源分配的基本单位，各个进程拥有相互独立的内存地址空间，为了保证安全，一个进程不能直接访问另一个进程的地址空间

进程通信指的就是进程之间的信息交换，进程通信有以下几种实现方式：

- 共享存储
  - 基于数据结构的共享
  - 基于存储区的共享
- 消息传递
  - 直接通信方式
  - 间接通信方式
- 管道通信

**共享存储**

由于每个进程不能直接访问对方的内存地址空间，为了实现信息交换，操作系统为两个进程专门开辟出一块共享空间，两个进程对共享空间的访问必须是互斥的(通过操作系统提供的同步互斥工具PV等实现)。

基于共享空间的进程通信有两种方式：

- 基于数据结构的共享：共享空间只能存放某种类型的数据结构，如长度为10的数组；这种共享方式速度低，限制多，是一种低级的通信方式
- 基于存储区的共享：在内存中画出一块共享存储区，数据的形式和存放位置都有进程控制，这种方式速度更快，是一种高级通信方式

**管道通信**

管道是指用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟出一个固定大小的缓冲区

- 管道只能采用半双工，如果需要实现全双工需要两个管道

- 各个进程对管道的访问需要互斥
- 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据读走，当管道为空时，读进程的read()系统调用将被阻塞，等待写入
- 如果未写满，不允许读数据；如果未读空，不允许写
- 数据一旦被读出，就从管道中抛弃，意味着读进程最多只有一个

**消息传递**

进程间的数据交换以格式化消息为单位，进程通过操作系统提供的"发送消息/接收消息"两个原语进行数据交换

消息包含消息头、消息体两部分，消息头主要包含发送进程ID，接收进程ID，消息类型，消息长度等信息(计算机网络中发送的报文其实就是一种消息)

消息传递分为两种方式：

- 直接通信方式：每个进程会有一个消息缓冲队列，直接通信方式即通过发送原语将消息直接发送到目标进程的缓冲队列里
- 间接通信方式：将消息发送到一个中间实体，类似于计算机网络中的电子邮件系统

### 线程

由于进程是资源分配的基本单位和调度的基本单位，因此当进程切换时，需要保存和恢复现场环境，切换内存地址空间等，开销非常大，为了降低这个开销，引入了线程的概念。

一个进程里包含多个线程，每个线程负责不同的任务，他们共享进程的内存地址空间，线程切换时少去了内存地址空间切换和进程运行环境恢复的消耗，只需要恢复寄存器等少量现场信息即可。

线程优点：

- 并发带来的系统开销降低，系统并发性提升
- 进程之间不可以直接通信，通信需要请求系统服务，会导致CPU切换核心态，而由于线程共享进程内存空间，因此彼此之间可以直接通信

**引入线程之后，线程成为CPU调度的最小单位，线程也有类似于进程的五种状态**

> 进程是资源分配的基本单位，线程几乎不拥有资源，只拥有极少量的资源，如线程控制块TCB，寄存器信息，堆栈等

### 线程的实现方式

线程的实现方式有以下几种：

**用户级线程**

早期的操作系统只支持进程，不支持线程，这种线程是由用户自行通过线程库实现的，整体逻辑类似于while(true)不断轮询，根据标志位执行不同的逻辑，模拟多线程

用户级线程特点：

- 线程的管理工作由用户负责
- 线程切换不需要从用户态切换内核态
- 操作系统对多线程无感知

用户级线程优缺点：

- 线程切换不需要操作系统从用户态切换内核态，线程管理开销小，效率高
- 当一个线程被阻塞后，整个进程都被阻塞，并发度不高
- 多个线程不可以在多核处理器上并发运行
- 线程完全靠用户自己模拟实现，线程的管理也有用户负责，编写麻烦

**内核级线程**

内核级线程即由操作系统实现的线程

内核级线程特点：

- 线程管理工作由操作系统负责
- 线程切换需要从用户态变为内核态
- 操作系统能感知到多线程

内核级线程优缺点：

- 一个线程被阻塞后，别的线程还可以继续执行，并发度高
- 多个线程可以在多核CPU上并发运行
- 一个用户进程会占用多个内核线程，线程切换导致的用户态和内核态的转换开销太大

**多线程模型**

为了在用户级线程和内核级线程之间做出均衡，引入多线程模型。

在支持内核级线程的操作系统上，根据用户级线程和内核级线程的映射关系，可以划分为以下几种多线程模型：

- 一对一模型：一个用户级线程映射到一个内核级线程
  - 一个线程阻塞后，其他线程还能执行，并发度高，且多核CPU可以多线程并发运行
  - 一个用户进程会占用多个内核级线程，线程切换开销大
- 多对一模型：多个用户级线程映射到一个内核级线程，且一个进程只被分配一个内核级线程
  - 与用户级线程类似
- 多对多模型：n个用户级线程映射到m个内核级线程(n>=m)，每个用户进程对应m个内核级线程
  - 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占据太多内核级线程导致的开销大问题
  - 用户级线程封装代码逻辑，内核级线程用来获取CPU使用权











# <a id="nc">内存管理</a>















# <a id="wj">文件管理</a>





# <a id="io">IO管理</a>

