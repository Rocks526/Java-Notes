# 镜像介绍

### 镜像简介

Docker的镜像类似于VMware的iso文件，里面包含了系统和应用相关的信息。

想要启动一个Docker容器，需要先从镜像仓库服务中拉取镜像。常见的镜像仓库服务是Docker Hub，但是也存在其他镜像仓库服务。拉取操作会将镜像下载到本地Docker主机，可以使用该镜像启动一个或者多个容器。

> 镜像是静态的，容器是动态的，类似于类和对象的关系。

镜像由多个层组成，每层叠加之后，从外部看来就如一个独立的对象。镜像内部是一个精简的操作系统（OS），同时还包含应用运行所必须的文件和依赖包。因为容器的设计初衷就是快速和小巧，所以镜像通常都比较小。

> 很多应用的镜像使用的都是Centos的最小包环境，因此很多命令都没有，需要自行安装。

### 镜像的分层存储

Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变。

因为镜像包含系统完整的root文件系统，其体积往往是庞大的，因此在Docker设计时，就充分利用联合文件（Union FS）技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说由多层系统联合组成。

镜像构建时会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层，比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。

分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需要的内容，构建新的镜像。

> 镜像分层示例

![image-20201207115614514](http://rocks526.top/lzx/image-20201207115614514.png)

# 镜像相关的命令

- 查看镜像

docker images

> 返回结果解析：
>
> REPOSITORY：镜像名称
>
> TAG：镜像标签
>
> IMAGE ID：镜像ID
>
> CREATED：镜像的创建日期（不是获取该镜像的日期）
>
> SIZE：镜像大小

- 搜索镜像

docker search 镜像名称

> 返回结果解析：
>
> NAME：仓库名称/镜像名称
>
> DESCRIPTION：镜像描述
>
> STARS：用户评价，反应一个镜像的受欢迎程度
>
> OFFICIAL：是否官方
>
> AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的

- 拉取镜像

docker pull 镜像名称:镜像标签

例如：docker pull centos:7

- 删除镜像

docker rmi 镜像ID或镜像名称:镜像标签

例如：docker rmi centos:7

> 删除所有镜像：docker rmi \`docker images -aq`
>
> docker images -q命令是返回所有镜像ID
>
> -f参数强制删除

- 查看镜像详细信息

docker image inspect 镜像ID或镜像名称:镜像标签

- 容器导出镜像

docker commit 容器名字 导出的镜像名

> 例如：docker commit flask_demo flask_demo
>
> 容器不需要启动也可以导出镜像

- 镜像备份

docker save -o 保存的文件名 镜像名

> 例如：docker flask_demo_iamge.tar flask_demo

- 镜像恢复

docker load -i 镜像文件的名字

> 例如：docker load flask_demo_image.tar

- 镜像推送远程仓库

docker push 用户名/镜像名:标签版本

> 例如：docker push rocks/flask_demo:v1