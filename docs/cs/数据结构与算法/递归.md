# 一：递归的介绍

### 1.1 递归的介绍

递归是一种应用非常广泛的`算法/编程技巧`，很多高级的数据结构和算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等。

递归虽然写起来较难，但理解起来很简单，例如现实生活中去看电影，你想知道你现在的座位是第多少排，你可以问前面的那个人是多少排，然后加一即可，前面的人同理，直到第一排的人，他知道自己是第一排，如此即可算出你是多少排。

这就是一个非常标准的递归求解问题的分解过程，去的过程叫"递"，回来的过程叫"归"。基本上，`所有的递归问题都可以用递推公式来表示。`刚才这个例子用递归公式表示就是：

```xml
f(n) = f(n-1) + 1， 其中，f(1) = 1
```

f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，就可以很轻松地将它改为递归代码，如下：

```java
int f(n){
    if (n == 1) return 1;
    return f(n-1) + 1;
}
```

判断一个问题是否可以通过递归解决，需要满足这三个条件：

- 一个问题的解可以分解为几个子问题的解
- 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
- 存在递归终止条件

### 1.2 递归的技巧

理解了递归的思路，那么如何通过递归解决问题？最重要的就是`写出递推公式，找到终止条件`。然后将递归公式转换为代码即可。

例如现在有N个台阶，每次你可以跨1个台阶或者2个台阶，请问走这N个台阶有多少种走法？

这个问题可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以N个台阶的走法就等于先走1阶后，N-1个台阶的走法加上先走2阶后，N-2个台阶的走法。用公式表示就是：

```
1 f(n) = f(n-1)+f(n-2)
```

有了递推公式，递归代码基本上就完成了一半。我们再来看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法，当只有两个台阶的时候，我们可以直接走或者分两步走，因此由两种走法。

然后把递归终止条件和刚刚得到的递推公式放到一起就是这样的：

```
1 f(n) = f(n-1)+f(n-2)，其中f(1) = 1，f(2) = 2
```

转换为代码如下：

```java
int f(n){
    if (n == 1) return 1;
    if (n == 2) return 2;
    return f(n-1) + f(n-2);
}
```

总结一下，`写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码`。

听起来比较简单，在刚才电影院的例子中，递归的调用只有一个分支，即一个问题只需要分解为一个子问题，因此能很容易想清"递"和"归"的每一个步骤，因此写起来容器。但当一个问题需要分解为多个子问题的时候，人脑就很难想清楚"递"和"归"的每一个步骤，因此就很难找出递归公式和终止条件。

计算机擅长做重复的事情，所以递归正和它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。

对于递归代码，`这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。`正确的思考方式是，如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，就会容易思考很多。

因此，`编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。`

### 1.3 递归存在的问题

- 警惕堆栈溢出

函数调用会使用栈来保存临时变量，每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

那么，如何避免出现堆栈溢出呢？

我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如1000）之后，我们就不继续往下再递归了，直接返回报错。例如刚才电影院的例子：

```java
int depth = 0;
int f(n){
    ++depth;
    if (depth > 1000) {
        throw new IllegalArgumentException("depth is too big!");
    }
    
    if (n == 1) return 1;
    return f(n-1) + 1;
}
```

但这种做法并不能完全解决问题，因为`最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性`。所以，`如果最大深度比较小，比如10、50，就可以用这种方法，否则这种方法并不是很实用。如果深度特别大，建议改为非递归的方式`。

- 警惕重复计算

除此之外，使用递归时还会出现重复计算的问题。刚才走台阶的例子，如果我们把整个递归过程分解一下的话，那就是这样的：

![image-20220311115139522](http://rocks526.top/lzx/image-20220311115139522.png)

从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。

为了避免重复计算，`我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)`。 当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回， 不需要重复计算，这样就能避免刚讲的问题了。

```java
    private HashMap<Integer, Integer> result = new HashMap<>();

    public int climbStairs(int n) {
        if (n < 1){
            throw new IllegalArgumentException("N must greater than zero!");
        }
        if (n == 1){
            return 1;
        }
        if (n == 2){
            return 2;
        }
        if (result.containsKey(n)){
            return result.get(n);
        }
        int v = climbStairs(n - 1) + climbStairs(n - 2);
        result.put(n, v);
        return v;
    }
```

### 1.4 将递归代码改为非递归

递归有利有弊，`利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题`。所以， 在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。

`所有的递归代码都可以改为迭代循环的非递归写法`，当递归的栈比较深时建议改为非递归方式实现，避免栈溢出异常。

将刚才走台阶的例子改为非递归实现如下：

```java
    public int climbStairs(int n) {
        if (n < 1){
            throw new IllegalArgumentException("N must greater than zero!");
        }
        if (n == 1){
            return 1;
        }
        if (n == 2){
            return 2;
        }
        // 最终值
        int v = 0;
        // 子问题的解, f(n-1) f(n-2)
        int pre = 2;
        int pre2 = 1;
        for (int i=3;i<=n;i++){
            // 递推公式
            v = pre + pre2;
            pre2 = pre;
            pre = v;
        }
        return v;
    }
```

递归本身就是借助栈来实现的，`只不过我们使用的栈是系统或者虚拟机本身提供的`，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。

但是这种思路实际上是将递归改为了"手动"递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。

# 二：LeetCode

### 2.1 LeetCode#70 ：爬楼梯

- 题目介绍

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

- 示例

> 输入：n = 2
> 输出：2
> 解释：有两种方法可以爬到楼顶。
>
> 1 阶 + 1 阶
>
> 2 阶

- 代码

```java
package com.lizhaoxuan.leetcode.recursion;

import java.util.HashMap;

/**
 * LeetCode#70 : 爬楼梯
 * @author lizhaoxuan
 */
public class ClimbStairs {

    public int climbStairs(int n) {
        if (n < 1){
            throw new IllegalArgumentException("N must greater than zero!");
        }
        if (n == 1){
            return 1;
        }
        if (n == 2){
            return 2;
        }
        return climbStairs(n - 1) + climbStairs(n - 2);
    }

    private HashMap<Integer, Integer> result = new HashMap<>();

    /**
     * 缓存一下计算结果，避免重复计算
     */
    public int climbStairs_2(int n) {
        if (n < 1){
            throw new IllegalArgumentException("N must greater than zero!");
        }
        if (n == 1){
            return 1;
        }
        if (n == 2){
            return 2;
        }
        if (result.containsKey(n)){
            return result.get(n);
        }
        int v = climbStairs(n - 1) + climbStairs(n - 2);
        result.put(n, v);
        return v;
    }

    /**
     * 递归改for循环
     * @param n
     * @return
     */
    public int climbStairs_3(int n) {
        if (n < 1){
            throw new IllegalArgumentException("N must greater than zero!");
        }
        if (n == 1){
            return 1;
        }
        if (n == 2){
            return 2;
        }
        // 最终值
        int v = 0;
        // 子问题的解, f(n-1) f(n-2)
        int pre = 2;
        int pre2 = 1;
        for (int i=3;i<=n;i++){
            // 递推公式
            v = pre + pre2;
            pre2 = pre;
            pre = v;
        }
        return v;
    }

}
```

