# 一：JMeter介绍

### 1.1 JMeter介绍

JMeter是一款使用Java开发的`开源免费`、`易于使用`、`功能强大`、`扩展性强`的测试工具，主要用来做功能测试和性能测试（压力测试/负载测试），支持以下功能：

- 性能测试及压力测试
- 数据库测试
- Java程序的测试
- Http及Ftp的测试
- ...........

JMeter官网：http://jmeter.apache.org。

### 1.2 JMeter特点

性能测试有很多工具，JMeter、Loadrunner、Locust、nGrinder等，JMeter相比其他的工具，有以下优点：

- `开源免费、安装简易、多系统兼容`：相对于 Loadrunner，JMeter没有版权的困扰，脚本可以在Windows、Linux、Mac任意系统间切换，非常简单方便
- `丰富的基础插件`：相对于 Locust，JMeter 提供了较多的插件，可以减少重复造轮子的工作
- `良好的拓展性`：虽然 JMeter 已经有了丰富的基础插件，它本身还是提供了入口进行二次开发，以满足团队定制化的需求，也可以将 JMeter 平台化，通过平台化的操作来管理 JMeter

### 1.3 JMeter安装

#### 1.3.1 Windows安装

- 下载安装包

安装包下载地址：https://jmeter.apache.org/download_jmeter.cgi

- 解压安装包

![image-20220421180714568](http://rocks526.top/lzx/image-20220421180714568.png)

bin目录为启动脚本目录，里面有Jmeter.bat和Jmeter.jar，点击即可启动GUI页面。

> 注：JMeter采用Java编写，因此需要安装Jdk。

- 修改配置文件

bin目录下的`jmeter.properties`是JMeter的全局配置文件，修改内容如下：

```properties
# 修改GUI页面文字为中文
language=zh_CN  
```

### 1.3.2 Linux安装JMeter

- 上传安装包并解压

```shell
tar -zxvf apache-jmeter-5.4.3.tgz 
```

- 解压后目录结构和windows版本一致，bin目录即可启动

# 二：JMeter快速入门

### 2.1 JMeter快速入门

下面以一个SpringBoot服务写的时钟服务器为例进行压测，压测接口会返回当前服务器的时间。

- 创建一个仓库目录，用于存放用来压测的脚本

![image-20220421190854020](http://rocks526.top/lzx/image-20220421190854020.png)

- 打开JMeter工具，修改测试计划名称并保存

![image-20220421190949506](http://rocks526.top/lzx/image-20220421190949506.png)

- 添加线程组，设置并发数

![image-20220421191408515](http://rocks526.top/lzx/image-20220421191408515.png)

![image-20220421191305411](http://rocks526.top/lzx/image-20220421191305411.png)

线程数：一个用户占一个线程，10个线程就是模拟10个用户

Ramp-Up Period(in seconds): 设置线程需要多长时间全部启动，如果线程数为200 ，准备时长为10，那么需要1秒钟启动20个线程。

Loop Count: 每个线程发送请求的次数，如果线程数为200，循环次数为10，那么每个线程发送10次请求，总请求数为200*10=2000。如果勾选了"永远"，那么所有线程会一直发送请求，直到主动停止运行脚本。

- 添加HTTP请求

![image-20220421191745571](http://rocks526.top/lzx/image-20220421191745571.png)

![image-20220421192033804](http://rocks526.top/lzx/image-20220421192033804.png)

注：参数较多时，可以通过下面的列表框填入，请求体内容也可以通过下面的消息体数据传入。

- 添加结果查看器

![image-20220421192236649](C:\Users\lizhaoxuan\AppData\Roaming\Typora\typora-user-images\image-20220421192236649.png)

![image-20220421192511288](http://rocks526.top/lzx/image-20220421192511288.png)

常用的结果观察组件有以上几个，在正式压测环境中，结果统计和GUI页面会影响客户端发压性能，建议用命令行方式，结果统计为html。

- 开始压测

![image-20220421192651925](http://rocks526.top/lzx/image-20220421192651925.png)

- 查看结果

![image-20220421192925348](http://rocks526.top/lzx/image-20220421192925348.png)

查看结果树可以查看请求和响应的报文相关的信息。

![image-20220421192954016](http://rocks526.top/lzx/image-20220421192954016.png)

聚合报告也是最常用的一个报告，可以查看一些统计信息，比如当前99%的请求都在96ms内返回，错误率为0，QPS为357。

### 2.2 测试结果分析

- 为什么QPS这么低？

线程组默认行为是多个线程并发发送请求，每个线程在获取到请求响应之后再发下一次请求。根据90%请求耗时27ms的信息可计算出，每个线程每秒发送的请求数为1000/27=37，因此10个线程并发，则每秒总请求数为370，即370QPS。

- 怎么评估服务器的性能？

QPS代表每秒请求数，等于`并发数*(1/请求耗时)`，因此QPS和并发成正比，和请求耗时成反比。那么，是否并发越高，QPS越高？

答案是否定的，在一定的并发区间内，QPS和并发是呈正比的；并发达到程序极限后，程序由于各种锁竞争、线程切换等消耗，QPS会达到瓶颈；继续往上追加并发，程序的性能会急剧降低。因此，一般程序最好保持在临界点。

![img](http://rocks526.top/lzx/91b6a9d974feeacb6fe43a62bbf3a61a.png)

如上图所示，横轴为并发数，绿色的线为系统资源利用率，紫色的线为QPS，蓝色的线为响应时间。根据这个图，可以划分为三个区域：低负载区、高负载区、系统崩溃区。

性能测试的最终目的就是摸清楚每个区域的临界点在哪里，因此会划分出多种测试类型：

1. 性能测试：测试在低负载区域之内，是否可以达到性能预期
2. 负载测试：在对系统不断增加并发，直到某项资源达到安全临界值（高负载区），即测试性能最高的点的位置
3. 压力测试：继续加压，系统性能快速下降，最终奔溃，即测试系统的崩溃点在哪里（崩溃区）
4. 稳定性测试：稳定性测试算是性能测试的一种，即测试长时间的高并发的压力下（高负载区），系统是否和原来一样稳定

![img](http://rocks526.top/lzx/5586521-51d778d9754f53eb.png)

注：以上都是基于整体的吞吐量和资源利用的角度来说的，如果是面向用户的程序，对响应时间比较敏感，在提升并发的同时，也要关注响应时间的指标。一般来说，响应时间分为三个档次：300ms，1s，3s。超过3s，用户体验会严重下降。

### 2.3 完整测试

假设压测目标为：要求系统无报错，99%请求1s内响应，95%请求300ms内响应，测试出系统的各个临界点在哪儿。

- 并发改为100，压测结果如下：

![image-20220421220702092](http://rocks526.top/lzx/image-20220421220702092.png)

QPS增长至2000+，99%请求耗时在119ms内，95%请求耗时在70ms内，处于低负载区，继续加大并发。

- 并发改为200，压测结果如下：

![image-20220421221018265](http://rocks526.top/lzx/image-20220421221018265.png)

QPS增长至3000+，99%请求耗时在131ms内，95%请求耗时在82ms内，处于低负载区，继续加大并发。

- 并发改为300，压测结果如下：

![image-20220421221445755](http://rocks526.top/lzx/image-20220421221445755.png)

QPS保持在3000+没有变，99%请求耗时在324ms内，95%请求耗时在159ms内，说明并发在达到200后，系统已经进入高负载区。

- 并发改为400，压测结果如下：

![image-20220421221813177](http://rocks526.top/lzx/image-20220421221813177.png)

QPS略微降低，99%请求耗时在377ms内，95%请求耗时在163ms内，说明系统已经还处于高负载区。

- 并发改为600，压测结果如下：

![image-20220421223825253](http://rocks526.top/lzx/image-20220421223825253.png)

QPS基本稳定，99%请求耗时在449ms内，95%请求耗时在230ms内，说明系统还处于高负载区。

- 并发改为800，压测结果如下：

![image-20220421224839373](http://rocks526.top/lzx/image-20220421224839373.png)

QPS基本稳定，99%请求耗时在972ms内，95%请求耗时在536ms内，说明系统还处于高负载区。

注：由于95%的指标已经超出要求，因此后续不再做测试了。

- 总结

由于客户端机器性能一般，并且服务端的接口很简单，只是返回当前服务器当前时间，因此直到客户端性能快达到瓶颈时，`依旧没有测试出崩溃区的临界点在哪里`，针对这种情况，可以考虑找一台服务器进行命令行压测、或者分布式JMeter进行压测。

针对上面的测试结果，表明`并发数达到200时，系统进入高负载区，QPS的峰值能达到3K+，在200-800的并发区域内，会随着并发数的增长请求逐渐变慢，但不会进入崩溃区`。

# 三：JMeter核心概念

### 3.1 组件与元件

组件和元件是JMeter的核心概念之一，`每个组件都具备不同的功能，每个组件又包含一系列元件，元件是每个组件相似功能的不同实现`，例如监听器就是一个组件，用于对请求的结果进行统计、分析等，包含用于获取响应报文的查看结果树元件、用于生成报告的聚合报告元件、还有其他响应时间分析等元件。

![图片2.png](https://s0.lgstatic.com/i/image/M00/8C/F5/CgqCHl_2gVaAEnd0AACHVOgTgLo426.png)

### 3.2 组件的分类

JMeter 有多种组件，重点看下这七类：` 配置元件、取样器、定时器、前置处理器、后置处理器、断言、监听器`。下面来看下它们各自的作用：

- 配置元件：`用于初始化变量`，以便采样器使用；类似于框架的配置文件，参数化需要的配置都在配置元件中
- 取样器：`承担 JMeter 发送请求的核心功能`，支持多种请求类型，如 HTTP、FTP、JDBC 等，也可以使用 Java 类型的请求进行自定义编写
- 定时器：`一般用来指定请求发送的延时策略`；在没有定时器的情况下，JMeter 发送请求是不会暂停的
- 前置处理器：`在进行取样器请求之前执行一些操作`，比如生成入参数据
- 后置处理器：`在取样器请求完成后执行一些操作`，通常用于处理响应数据，从中提取需要的值进行下一步操作
- 断言：`主要用于判断取样器请求或对应的响应是否返回了期望的结果`
- 监听器：`监听器可以在 JMeter 执行测试的过程中搜集相关的数据，然后将这些数据在 JMeter 界面上以树、图、报告等形式呈现出来`；不过图形化的呈现非常消耗客户端性能，在正式性能测试中并不推荐使用

### 3.3 组件的顺序

JMeter的组件存在一定执行顺序，具体如下所示：

![图片1.png](https://s0.lgstatic.com/i/image/M00/8C/F5/CgqCHl_2gWOAcj4PAADsoHDndjA019.png)

### 3.4 元件的作用域

JMeter的元件都可重复添加，JMeter会根据一定层级结构进行组织，划定每个元件的作用范围，如下所示：

![Drawing 5.png](https://s0.lgstatic.com/i/image2/M01/04/AF/Cip5yF_1He-ALsdzAACx-Dpj8Qo799.png)

在图中可以看到，在不同位置放了 3 个一样的元件“查看结果树”，运行后发现，查看结果树 1 里面显示了 HTTP1 和 HTTP2，而插件结果树 2 里只有 HTTP1，查看结果树 3 里面只有 HTTP2。

这就是JMeter元件的作用域，JMeter会以树状结构组织所有的元件，父级元件对子元件也可生效。