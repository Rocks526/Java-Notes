# 一：排序算法介绍

### 1.1 排序算法介绍

排序算法非常重要，大多数人接触到的第一个算法就是排序算法。大部分编程语言中，也都提供了排序函数。

排序算法非常多，有很多都没有听过名字的排序算法，例如：猴子排序、睡眠排序、面条排序等。此处只介绍一些最经典、常用的排序算法：`冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。`

### 1.2 排序算法评价指标

学习排序算法，除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。分析一个排序算法有如下指标：

#### 1.2.1 排序算法的执行效率

- 最好情况、最坏情况、平均情况时间复杂度

我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。

为什么要区分这三种时间复杂度呢？

第一，有些排序算法会区分，为了好对比，所以最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。

- 时间复杂度的系数、常数、低阶

时间复杂度反应的是数据规模N很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是10个、100个、1000个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候， 我们就要把系数、常数、低阶也考虑进来。

- 比较次数和交换（或移动）次数

基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

#### 1.2.2 排序算法的内存消耗

算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，还引入了一个新的概念，原地排序。`原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。`

#### 1.2.3 排序算法的稳定性

仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，`稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。`

为什么要区分排序算法的稳定性？

例如存在如下需求：给电商交易系统中的"订单"排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果现在有 10 万条订单数据，希望按照金额从小到大对订单数据排序。对于金额相同的订单，希望按照下单时间从早到晚有序。

最先想到的方法是：先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。

借助稳定排序算法，这个问题可以非常简洁地解决：先按照下单时间给订单排序，排序完成之后，`用稳定排序算法`，按照订单金额重新排序。两遍排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。

### 1.3 逆序度

有序度是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：

```
有序元素对：a[i] <= a[j], 如果 i < j。
```

![image-20220311174214660](http://rocks526.top/lzx/image-20220311174214660.png)

同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；`对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是n*(n-1)/2`，也就是15。`我们把这种完全有序的数组的有序度叫作满有序度。`

逆序度的定义正好跟有序度相反（默认从小到大为有序），关于这三个概念，我们还可以得到一个公式：`逆序度 = 满有序度 - 有序度。`我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

# 二：冒泡排序

### 2.1 冒泡算法介绍

冒泡排序`只会操作相邻的两个数据`。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。`一次冒泡会让至少一个元素移动到它应该在的位置`，重复 n 次，就完成了 n 个数据的排序工作。

例如要对一组数据 4，5，6，3，2，1，从小到到大进行排序。第一次冒泡操作的详细过程如下：

![image-20220311173542813](http://rocks526.top/lzx/image-20220311173542813.png)

可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。

![image-20220311173615484](http://rocks526.top/lzx/image-20220311173615484.png)

实际上，刚讲的冒泡过程还可以优化。`当某次冒泡操作已经没有数据交换时，说明已经达到完全有序`，不用再继续执行后续的冒泡操作。

![image-20220311173702588](http://rocks526.top/lzx/image-20220311173702588.png)

### 2.2 冒泡算法实现

```java
    /**
     * 冒泡排序
     *      每次比较相邻两个元素大小，一轮比较完成后，最大/最小的元素排到末尾
     *      循环N轮后，数组实现有序
     *      优化：当某一轮比较完成后，没有交换元素，意味着已经有序了，可以不用继续遍历了。
     */
    public static void BubbleSort(int[] array){
        if (array == null || array.length == 0){
            return;
        }
        // 外层循环是轮数，N轮
        for (int i=0;i<array.length;i++){
            // 本轮是否存在交换标识
            boolean flag = false;
            // 每次都是从第一个元素开始比较，因此j从0开始，比较的末尾为数组长度减去轮数，再减1是因为要访问j+1的下标
            for (int j=0;j<array.length - i - 1;j++){
                if (array[j] > array[j+1]){
                    int tmp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = tmp;
                    flag = true;
                }
            }
            if (!flag) return;
        }
    }
```

- 冒泡排序需要遍历N次，因此外层循环是N
- 内层循环每次从第一个元素开始，访问到上次排好序的元素截止，即0到N-i，由于要对比当前元素和下一个元素，因此需要N-i-1

### 2.3 冒泡算法指标分析

- 冒泡排序是原地排序算法吗？

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的`空间复杂度为 O(1)，是一个原地排序算法`。

- 冒泡排序是稳定的排序算法吗？

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以`冒泡排序是稳定的排序算法`。

- 冒泡排序的时间复杂度是多少？

最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以`最好情况时间复杂度是 O(n)`。

最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以`最坏情况时间复杂度为 O(n^2)`。

平均时间复杂度用概率论的方法定量分析会很复杂，可以通过"有序度"和"逆序度"两个概念进行分析。冒泡排序包含两个操作原子，比较和交换，每交换一次，有序度就加 1，不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2 – 初始有序度。

对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n(n-1)/2 次交换。最好情况下，初始状态的有序度是 n\*(n-1)/2，就不需要进行交换。我们可以取个中间值 n\*(n-1)/4，因此`平均情况下的时间复杂度就是 O(n^2)。`

# 三：插入排序

### 3.1 插入排序介绍

插入排序是将数组分为两部分，一部分有序区间，一部分无序区间，`不断地从无序区间里取出元素，插入到有序区间中的合适位置`，当有序区间为空时即实现整个数组的排序。

例如要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间：

![image-20220322150149922](http://rocks526.top/lzx/image-20220322150149922.png)

插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，`移动操作的次数总是固定的，就等于逆序度。`

### 3.2 插入排序实现

```java
    /**
     * 插入排序：
     *      将数组分为有序和无序两个区间，不断从无序区间取出元素，按照顺序插入到有序区间里
     *      最开始，有序区间只有第一个元素
     */
    public static void InsertionSort(int[] array){
        if (array == null || array.length == 0){
            return;
        }
        // 外层循环是无序区间的元素遍历，从第二个元素开始
        for (int i=1;i<array.length;i++){
            // 要插入的元素
            int v = array[i];
            // 有序区间从后往前遍历，元素可以直接往后覆盖，不用存储
            int j = i -1;
            for (;j>=0;j--){
                if (array[j] > v){
                    // 大于再往后移，等于则插入后面，可以保证稳定性
                    array[j+1] = array[j];
                }else {
                    break;
                }
            }
            // 插入操作需要放到子循环之外，因为插入的元素可能在0下标，永远走不进else逻辑
            array[j+1] = v;
        }
    }
```

- 内层for循环用于查找插入点，插入的操作注意放到for循环之外，因为可能所有元素都大于目标元素，导致进不去else逻辑

### 3.3 插入排序指标分析

- 插入排序是原地排序算法吗？

插入排序算法的运行并不需要额外的存储空间，所以`空间复杂度是 O(1)，这是一个原地排序算法`。

- 插入排序是稳定的排序算法吗？

在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以`插入排序是稳定的排序算法`。

- 插入排序的时间复杂度是多少？

如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，`最好是时间复杂度为O(n)`。

如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，`所以最坏情况时间复杂度为 O(n^2)`。

在数组中插入一个数据的平均时间复杂度是是 O(n)，所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，`所以平均时间复杂度为 O(n^2)`。

# 四：选择排序

### 4.1 选择排序介绍

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是`选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾`。

![image-20220322152251834](http://rocks526.top/lzx/image-20220322152251834.png)

### 4.2 选择排序实现

```java
    /**
     * 选择排序：
     *      选择排序和插入排序的思路一致，都是将数组分为无序区间和有序区间
     *      区别在于插入排序是从无序区间随机取值，在有序的插入有序区间，而选择排序是每次从无序区间取出最小值，放到有序区间的末尾
     */
    public static void SelectionSort(int[] array){
        if (array == null || array.length == 0){
            return;
        }
        // 外层循环，代表要插入N次
        for (int i=0;i<array.length;i++){
            int v = array[i];
            int v_index = i;
            // 内层循环，代表从无序区间里选择最小的元素
            for (int j=i;j<array.length;j++){
                if (array[j] < v){
                    v = array[j];
                    v_index = j;
                }
            }
            // 插入有序区间末尾
            array[v_index] = array[i];
            array[i] = v;
        }
    }
```

### 4.3 选择排序指标分析

- 选择排序是原地排序算法吗？

选择排序算法的运行并不需要额外的存储空间，所以`空间复杂度是 O(1)，这是一个原地排序算法`。

- 选择排序是稳定的排序算法吗？

`选择排序是一种不稳定的排序算法`，因为选择排序每次会选择最小元素与前面的元素交换位置，这样破坏了稳定性。

- 选择排序的时间复杂度是多少？

`选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)`。

# 五：快速排序

### 5.1 快速排序介绍

快排的核心思想也是分治，将数组不断划分为两个有序的子区间，具体划分的方式如下：

如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。

![image-20220322193223768](http://rocks526.top/lzx/image-20220322193223768.png)

根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。

快排和归并的区别：

![image-20220322193325011](http://rocks526.top/lzx/image-20220322193325011.png)

可以发现，`归并排序的处理过程是由下到上的`，先处理子问题，然后再合并。而快排正好相反，它的`处理过程是由上到下的`，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是`非原地排序算法`。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。`快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。`

### 5.2 快速排序实现

```java
    /**
     * 快速排序：不断选择分区点，将整个数组分为两个区间，将两个区间内小于分区点的元素放到左侧区间，两个区间内大于分区点的元素放到右侧区间内，即可实现有序
     */
    public static void QuickSort(int[] array){
        if (array == null || array.length < 2){
            return;
        }
        quickSort(array, 0, array.length - 1);
    }

    private static void quickSort(int[] array, int left, int right){
        if (left >= right){
            return;
        }
        // 分区并将分区两侧的数据排序
        int partition = partition(array, left, right);
        // 继续排序左侧
        quickSort(array, left, partition - 1);
        // 继续排序右侧
        quickSort(array, partition + 1, right);
    }

    private static int partition(int[] array, int left, int right) {
        // 获取分区点，直接取最后一个元素
        int partition = array[right];
        // 分区 为了避免额外空间，参考插入排序的思路，将所有数组分为小于区间和大于区间，将所有大于的元素与左侧的元素进行交换
        int index = left;
        while (left <= right - 1){
            if (array[left] < partition){
                int tmp = array[left];
                array[left] = array[index];
                array[index++] = tmp;
            }
            left++;
        }
        array[right] = array[index];
        array[index] = partition;
        return index;
    }
```

- 递归查询时，主要分区区间为left到partition-1和partition+1到right，而不是left到partition

### 5.3 快速排序指标分析

- 快速排序是原地排序算法吗？

分区的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的`空间复杂度为 O(1)，是一个原地排序算法`。

- 快速排序是稳定的排序算法吗？

分区的过程会涉及交换操作，可能将位置靠前的元素交换到后面，所以，`快速排序并不是一个稳定的排序算法`。

- 快速排序的时间复杂度是多少？

快排也是用递归来实现的，当分区函数选择比较合理时，每次划分为2个相等的区间，则`最好时间复杂度为O(nlogn)`。

当划分极度不均时，`最坏时间复杂度退化为O(n^2)`。

我们可以优化分区函数，近可能的分区均匀，从而实现`平均时间复杂度O(nlogn)`。

# 六：归并排序

### 6.1 归并排序介绍

归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

![image-20220322165926699](http://rocks526.top/lzx/image-20220322165926699.png)

归并排序使用的就是分治思想，分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。

### 6.2 归并排序实现

```java
    /**
     * 归并排序
     *      将整个数组不断划分为子数组，将子数组排序再进行合并
     */
    public static void MergeSort(int[] array){
        if (array == null || array.length < 2){
            return;
        }
        mergeSort(array, 0, array.length - 1);
    }

    private static void mergeSort(int[] array, int left, int right){
        if (left >= right){
            return;
        }
        int mid = (right + left) / 2;
        // 左边
        mergeSort(array, left, mid);
        // 右边
        mergeSort(array, mid + 1, right);
        // 归并
        merge(array, left, mid, mid + 1, right);
    }

    private static void merge(int[] array, int left, int mid, int mid2, int right) {
        // 记录一下起始下标，用于后续将tmp复制给array
        int bak = left;
        // 合并
        int[] tmp = new int[right - left + 1];
        int index = 0;
        while (mid >= left && right >= mid2){
            if (array[mid2] < array[left]){
                tmp[index++] = array[mid2++];
            }else {
                tmp[index++] = array[left++];
            }
        }
        while (mid >= left){
            tmp[index++] = array[left++];
        }
        while (right >= mid2){
            tmp[index++] = array[mid2++];
        }
        // 复制
        for (int v : tmp){
            array[bak++] = v;
        }
    }
```

### 6.3 归并排序指标分析

- 归并排序是原地排序算法吗？

归并排序在合并两个有序数组时需要额外辅助数组，`因此空间复杂度为O(N)，不是原地排序`。

- 归并排序是稳定的排序算法吗？

归并排序稳不稳定的关键要看合并函数，合并的时候针对相等的元素，将左侧区间的先合并即可实现元素相对位置不变，`所以，归并排序是一个稳定的排序算法`。

- 归并排序的时间复杂度是多少？

归并排序涉及递归，时间复杂度的分析稍微有点复杂，递归的时间复杂度计算可以通过递推公式计算：总耗时=子问题的耗时+归并的耗时。

假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：

```shell
T(n) = 2*T(n/2) + n
 = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
 = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
 = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
 ......
 = 2^k * T(n/2^k) + k * n
 ......
```

通过这样一步一步分解推导，我们可以得到 T(n) = 2^kT(n/2^k)+kn。当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。`所以归并排序的时间复杂度是 O(nlogn)`。

`归并排序的执行效率与要排序的原始数组的有序程度无关`，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。

# 七：桶排序

### 7.1 桶排序介绍

顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

![image-20220323142902313](http://rocks526.top/lzx/image-20220323142902313.png)

- 桶排序的适用场景

桶排序对要排序数据的要求是非常苛刻的，首先，`要排序的数据需要很容易就能划分成 m 个桶`，并且，`桶与桶之间有着天然的大小顺序`。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。其次，`数据在各个桶之间的分布是比较均匀的`。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。

`桶排序比较适合用在外部排序中。`所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

### 7.2 桶排序实现

```java
    /**
     * 桶排序：将所有元素划分到一堆有序的桶里，将每个桶内的元素排序，再将所有桶元素归并即可。
     */
    public static void BucketSort(int[] array){
        if (array == null || array.length < 2){
            return;
        }
        // 获取元素范围
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        for (int v : array){
            if (v > max){
                max = v;
            }
            if (v < min){
                min = v;
            }
        }
        // 划分桶 10个桶
        int step = (max - min) / 10;
        // 桶
        int[][] buckets = new int[10][];
        for (int i=0;i<10;i++){
            buckets[i] = new int[array.length];
        }
        // 用于记录每个桶的下标
        int[] index = new int[10];
        for (int v : array){
            // 计算要存放的桶下标
            int bucketIndex = (v - min) / step;
            if (bucketIndex >= 10){
                bucketIndex = 9;
            }
            // 更新桶元素和下标数组
            int[] bucket = buckets[bucketIndex];
            int curIndex = index[bucketIndex];
            bucket[curIndex++] = v;
            index[bucketIndex] = curIndex;
        }
        // 桶内排序
        for (int i=0;i<buckets.length;i++){
            quickSort(buckets[i], 0, index[i] - 1);
        }
        // 归并
        int j = 0;
        for (int i=0;i<buckets.length;i++){
            for (int k=0;k<index[i];k++){
                array[j++] = buckets[i][k];
            }
        }
    }
```

### 7.3 桶排序指标分析

- 桶排序是原地排序算法吗？

桶排序需要用到额外的辅助桶，空间复杂度为O(N)，`因此，不是原地排序算法`。

- 桶排序是稳定的排序算法吗？

桶排序在划分桶和归并的时候，保持元素的相对顺序不变，`可以实现稳定排序`。

- 桶排序的时间复杂度是多少？

如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。 当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，`这个时候桶排序的时间复杂度接近 O(n)。`因此最好时间复杂度和平均时间复杂度都是O(n)，当桶划分特别不均匀时，所有数据存放于一个桶内，`最坏时间复杂度退化为O(nlogn)`。

# 八：计数排序

### 8.1 计数排序介绍

`计数排序其实是桶排序的一种特殊情况`。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。`每个桶内的数据值都是相同的，省掉了桶内排序的时间`。

- 适用场景

`计数排序只能用在数据范围不大的场景中`，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

### 8.2 计数排序实现

```java
 /**
     * 计数排序：和桶排序思路一致，不过每个桶的大小都是1，可以省去桶内排序的时间开销。
     */
    public static void CountSort(int[] array){
        if (array == null || array.length < 2){
            return;
        }
        // 获取元素范围
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        for (int v : array){
            if (v > max){
                max = v;
            }
            if (v < min){
                min = v;
            }
        }
        // 划分桶
        int bucketCount = max - min + 1;
        // 桶
        int[][] buckets = new int[bucketCount][];
        for (int i=0;i<bucketCount;i++){
            buckets[i] = new int[array.length];
        }
        // 用于记录每个桶的下标
        int[] index = new int[bucketCount];
        for (int v : array){
            // 计算要存放的桶下标
            int bucketIndex = v - min;
            // 更新桶元素和下标数组
            int[] bucket = buckets[bucketIndex];
            int curIndex = index[bucketIndex];
            bucket[curIndex++] = v;
            index[bucketIndex] = curIndex;
        }
        // 归并
        int j = 0;
        for (int i=0;i<buckets.length;i++){
            for (int k=0;k<index[i];k++){
                array[j++] = buckets[i][k];
            }
        }
    }
```

### 8.3 计数排序指标分析

- 计数排序是原地排序算法吗？

计数排序也要用到额外的辅助桶，`空间复杂度O(N)，因此，不是原地排序算法`。

- 计数排序是稳定的排序算法吗？

计数排序和桶排序一致，在往桶内分散数据时保持相对顺序，即`可实现稳定排序`。

- 计数排序的时间复杂度是多少？

计数排序由于不需要桶内排序，`时间复杂度固定为O(N)`。

# 九：基数排序

### 9.1 基数排序介绍

假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？

刚刚这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。

借助稳定排序算法，这里有一个巧妙的实现思路：先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。

手机号码稍微有点长，画图比较不容易看清楚，用字符串排序的例子，画了一张基数排序的过程分解图：

![image-20220323144201259](http://rocks526.top/lzx/image-20220323144201259.png)

注意，`这里按照每位来排序的排序算法要是稳定的`，否则这个实现思路就是不正确的。

根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，`所以基数排序的时间复杂度就近似于 O(n)`。

- 适用场景

基数排序对要排序的数据是有要求的，`需要可以分割出独立的“位”来比较，而且位之间有递进的关系`，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，`每一位的数据范围不能太大`，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。

### 9.2 基数排序指标分析

- 基数排序是原地排序算法吗？

由于基数排序的每一位都需要用到线性排序，`因此空间复杂度O(N)，不是原地排序算法`。

- 基数排序是稳定的排序算法吗？

由于基数排序的位移操作只有每一位排序的时候，而每一位排序都是用线性排序，线性排序是稳定排序算法，`因此基数排序也是稳定排序算法`。

- 基数排序的时间复杂度是多少？

`基数排序的时间复杂度稳定O(N)`。

# 十：排序总结

| 排序算法 | 原地排序 | 稳定性 | 最好时间复杂度 | 最坏时间复杂度 | 平均时间复杂度 |
| -------- | -------- | ------ | -------------- | -------------- | -------------- |
| 冒泡排序 | √        | √      | O(N)           | O(N^2)         | O(N^2)         |
| 插入排序 | √        | √      | O(N)           | O(N^2)         | O(N^2)         |
| 选择排序 | √        | ×      | O(N^2)         | O(N^2)         | O(N^2)         |
| 快速排序 | √        | ×      | O(NlogN)       | O(N^2)         | O(NlogN)       |
| 归并排序 | ×        | √      | O(NlogN)       | O(NlogN)       | O(NlogN)       |
| 桶排序   | ×        | √      | O(N)           | O(NlogN)       | O(N)           |
| 计数排序 | ×        | √      | O(N)           | O(N)           | O(N)           |
| 基数排序 | ×        | √      | O(N)           | O(N)           | O(N)           |