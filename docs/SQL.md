

# <a id="jc">基础概念</a>

- 数据库：一个以某种有组织的方式存储的数据集合，通常是一个文件或一组文件
- 表：某种特定类型数据的结构化清单
- 列：表中的某个字段，有多种数据类型
- 行：表中的一个记录
- 主键：一列或一组列，用于唯一区分表中的每个行
- DBMS：数据库管理系统，多个DB加一个管理程序
- RDBMS：关系型DBMS
- SQL：结构化查询语言(Structured Query Language)的缩写，用于和RDBMS通信
- E-R图：设计数据库之间，需要抽象出现实实体之间的对应关系图，及ER图
- 范式：数据库设计需要遵循的标准，每个范式会不断地将大表拆分为小表，目的是保证数据安全(插入更新不会异常)，减少数据冗余，互联网一般遵循三范式，有时候为了查询性能，会增加一些冗余，实现反范式设计

### 常见DBMS

****

**RDBMS：关系型数据库，以行为单位存储数据，满足强ACID**

- MySQL
  - 开源的RDBMS，性能不错，广泛应用于互联网公司
- Oracle
  - 商业RDBMS，性能强，稳定性高，应用于金融，银行公司等
- SQL Server
  - 商业RDBMS
- PostgreSQL
  - 开源RDBMS，支持面向对象，表继承，json存储等特性
- SQLite
  - 小型嵌入式数据库，不需要BS架构，且迁移容易

**No SQL：非关系型数据库，对RDBMS的补充，增强扩展性，适合分布式部署，部分不满足强ACID**

- Redis
  - C高性能内存数据库，支持多种数据类型，持久化，事务(非RDBMS的事务)等，常用KV型存储
- MongoDB
  - 文档型NoSQL，支持分片，扩展性强，支持事务
- HBase
  - 列式存储NoSQL，同类型数据存储一块可以进行压缩存储，降低磁盘IO。适合大量数据的存储
- Neo4j
  - 图型数据库，适合多节点之间关系的查询，如人的社交网络等

**New SQL：新型数据库，解决RDBMS的扩展性问题，解决NoSQL的强ACID问题，一般由多种角色组成的分布式数据库**

- TiDB

**搜索引擎：主流DBMS虽然支持模糊匹配，但底层采用B+树性能较差，且不能实现关联查询，较为死板，而搜索引擎一般采用倒排索引，可以实现分词，打分，排序等功能**

- Lucene
  - 开源搜索核心功能包，一般搜索引擎都基于Lucene进行增强
- Solr
  - 传统搜索引擎，基于Lucene开发，支持分词，语法高亮等
- ElasticSearch
  - 目前主流搜索引擎，支持分片，扩展性强，实时性高

**文件存储：DBMS适合存储结构化数据，而音频，视频，图片等二进制数据需要采用文件服务器存储**

- FastDfs
  - 淘宝开源的C语言编写的高性能文件存储服务器
  - 适合存储一些中小型文件（4KB - 500MB之间）
  - 可实现冗余备份，负载均衡，线性扩容等功能
- Ceph










# 范式





**数据库表设计原则**

- 数据表的个数越少越好
  - RDBMS的核心在于对实体和联系的定义，也就是 E-R 图 （Entity Relationship Diagram），数据表越少，证明实 体和联系设计得越简洁，既方便理解又方便操作。
- 数据表中的字段个数越少越好
  - 字段个数越多，数据冗余的可能性越大。
  - 设置字段个数少的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。
  - 有时候为了提高检索效率，避免多次表联结，会建立一些冗余字段，设计时应该在数据冗余和检索效率中进行平衡。
- 数据表中联合主键的字段个数越少越好
  - 设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式
  - 联合主键中的字段越多，占用的索引空间越大
- 主键和外键的使用
  - 外键和主键本身是为了实现强一致性，保证数据安全，但相应的外键会降低系统性能
  - 在项目小的时候可以采用外键保证数据安全
  - 在项目大的时候，可以取消外键，数据一致性放在应用层去做，提升性能
  - 根据28原则，20%外键会造成80%的性能损耗，可以将这20%外键取消，采用业务层实现，一些必须保证安全的敏感数据可以采用外键







# 表约束

创建数据表的时候，会对字段进行约束，约束的目的在于保证 RDBMS 里面数据的**准确性和一致性**。

常见的约束有：

- 主键约束
  - 主键起的作用是唯一标识一条记录，不能重复，不能为空， 即UNIQUE+NOT NULL。一个数据表的主键只能有一个。 主键可以是一个字段，也可以由多个字段复合组成
- 外键约束
  - 外键确保了表与表之间引用的完整性。一个表中的外键对应另一张表的主键。外键可以是重复的，也可以为空。

- 唯一性约束
  - 唯一性约束表明了字段在表中的数值是唯一的，即使我们已经有了主键，还可以对其他字段进行唯一性约束
  - 唯一性约束相当于创建了一个约束和普通索引，目的是保证字段的正确性，而普通索引只是提升数据检索的速度，并不对字段的唯一性进行约束。
- NOT NULL 约束
  - 对字段定义了 NOT NULL，即表明该字段不应为空，必须有取值。
- DEFAULT
  - 表明了字段的默认值。如果在插入数据的时候，这个字段没有取值，就设置为默认值。
- CHECK 约束
  - 用来检查特定字段取值范围的有效性， CHECK约束的结果不能为 FALSE
  - CHECK(height>=0 AND height<3)

# 索引






# <a id="sql">SQL</a>

**SQL特点：**

- 声明式语言
  - 只需要告诉DBMS要做什么，具体怎么做由DBMS决定
- 面向集合
  - 游标是对面向集合的一种补充，实现面向过程的方式
- 半衰期长
  - 诞生于1974年，主要遵循SQL92和SQL99标准
- 通用性强
  - 除了RDBMS之外，还有怎么涉及数据处理的工具都支持SQL
- 学习简单，语义化明显
  - 查询SELECT，删除DELETE等，语义化明显

**SQL分类：**

- DDL(Data Definition Language)
  - 数据定义语言，用来定义数据库对象，如创建、修改、删除数据库，数据库表，列等
- DCL(Data Control Language)
  - 数据控制语言，用来定义和控制用户访问权限和数据库安全级别
- DML(Data Manipulation Language)
  - 数据操作语言，用来操作数据库相关的记录，如删除，创建，更新数据表中的记录
- DQL(Data Query Language)
  - 数据查询语言，用来查询数据库记录信息，也是SQL中的重点

**SQL语法**

- SQL语言是大小写不敏感的，但推荐采用以下方式
  - 表名，表别名，字段名，字段别名等采用小写
  - SQL保留字，函数名，绑定变量等采用大写

****

### DML

DDL 的英文全称是 Data Definition Language，中文是数据定义语言。它定义了数据库的结构和数据表的结构。

在DDL中，常用的功能是增删改，分别对应的命令是 CREATE、DROP 和 ALTER。需要注意的是，在执行DDL的时候，不需要 COMMIT，就可以完成执行任务。

```sql
> 以下环境皆基于PostgreSQL
# 创建数据库
CREATE DATABASE rocks;
# 删除数据库
DROP DATABASE rocks;
# 创建数据表
CREATE TABLE tb_user (
	user_id INT NOT NULL,
	user_name VARCHAR(255) NOT NULL
);
# 修改数据表 添加age字段
ALTER TABLE tb_user ADD age INT NOT NULL;
# 修改列名
ALTER TABLE tb_user RENAME COLUMN age to user_age;
# 删除字段
ALTER TABLE tb_user DROP COLUMN user_age;
```



### DQL

**SELECT查询的分类：**

- 单个SELECT的简单查询
- 子查询
- 联结查询
  - 内联结
  - 外联结
    - 左外联结
    - 右外联结
- 组合查询

**简单查询SQL的整体结构：**

```sql
SELECT
列名 AS 别名 
FROM 表名 
WHERE 限制条件 AND|OR 限制条件
GROUP BY 列名
HAVING 限制条件
ORDER BY 列名 ASC|DESC，列名2 ASC|DESC
LIMIT m,n;
```

**简单查询**

```sql
# 检索单列
SELECT username FROM users;
# 检索多列
SELECT username,password FROM users;
# 检索所有列
SELECT * FROM users;
# 起别名  -->  表也可以起别名
SELECT id AS userId FROM users;
# 查询常数 --> 填充一个常数作为某列的值
SELECT
id AS userId,
username AS username,
password AS password,
'通工1602' AS class,
FROM users;
# 结果去重 --> DISTINCT必须放在所有列名前面 对所有列名的组合去重，不能单列去重
SELECT DISTINCT username FROM users;
# 数据排序 --> 可以对多列进行排序 指定升/降序 可以对非选择列排序，如第二条SQL的id列 
SELECT * FROM users ORDER BY id;
SELECT username,password FROM users ORDER BY id ASC,username DESC;
# 约束返回结果数量 --> 从返回结果的第0条开始取 取5条记录
SELECT * FROM users ORDER BY id LIMIT 0,5;
# 数据过滤
SELECT * FROM users WHERE id >= 5;
SELECT * FROM users WHERE id IN (1,5,9) AND username = "Rocks";
```

**子查询**

```sql

```





**数据过滤**

SELECT时的数据过滤可以通过WHERE和HAVING实现，支持算数运算符，逻辑运算符，通配符等。

- 算数运算符

|        含义        |     运算符      |
| :----------------: | :-------------: |
|        等于        |        =        |
|       不等于       |     <>或!=      |
|        小于        |        <        |
| 小于等于（不大于） |     <=或!>      |
|        大于        |       \>        |
| 大于等于（不小于） |     \>=或!<     |
|       不小于       |       !<        |
|   在指定两数之间   | BETWEEN m AND n |
|       为空值       |     IS NULL     |

- 逻辑运算符

|       含义       | 逻辑运算符 |
| :--------------: | :--------: |
|       并且       |    AND     |
|       或者       |     OR     |
| 在指定条件范围内 |     IN     |
|        非        |    NOT     |

- 通配符

- > SQL中的模糊匹配使用LIKE关键字，支持以下通配符

  - %：任意字符出现任意次数
  - _：任意字符出现一次

**SQL函数**

不同的DBMS对SQL函数的支持有些区别，一般都包含以下五类：

> 如果以上函数不能满足需求，也可以自定义SQL函数

- 算数函数

| 函数名  |                             定义                             |
| :-----: | :----------------------------------------------------------: |
|  ABS()  |                           取绝对值                           |
|  MOD()  |                             取余                             |
| ROUND() | 四舍五入为指定的小数位，需要两个参数，分别为字段名称和小数位数 |

```sql
SELECT ABS(-2)   -->  2
SELECT MOD(101,2)  -->  1
SELECT ROUND(37.25,1)  -->  37.3
```

- 字符串函数

|    函数名     |                             定义                             |
| :-----------: | :----------------------------------------------------------: |
|   CONCAT()    |                       将多个字符串拼接                       |
|   LENGTH()    |     计算字符串长度；一个汉字算三个字符，数字，字母算一个     |
| CHAR_LENGTH() |           计算字符串长度；汉字，数字，字母都算一个           |
|    LOWER()    |                         字符串转小写                         |
|    UPPER()    |                         字符串转大写                         |
|   REPLACE()   | 字符串替换，三个参数，分别为：要替换的字段名，要被替换的字符， 替换字符 |
|  SUBSTRING()  | 截取字符串，三个参数：待截取的字段名，开始截取位置，截取的长度 |

```sql
SELECT CONCAT('ABC',123) --> ABC123
SELECT LENGTH('hello 你好') --> 12
SELECT REPLACE('ACBD','BD',123) --> AC123
SELECT SUBSTRING('ABUF',1,3) --> ABU
```

- 日期函数

|       函数名        |                定义                |
| :-----------------: | :--------------------------------: |
|   CURRENT_DATE()    |            系统当前时间            |
|   CURRENT_TIME()    |       系统当前时间，没有日期       |
| CURRENT_TIMESTAMP() | 系统当前时间，包括具体的日期和时间 |
|      EXTRACT()      |        抽取具体的年，月，日        |
|       DATE()        |         返回时间的日期部分         |
|       YEAR()        |         返回时间的年份部分         |
|       MONTH()       |         返回时间的月份部分         |
|        DAY()        |          返回时间的天部分          |
|       HOUR()        |         返回时间的小时部分         |
|      MINUTE()       |         返回时间的分钟部分         |
|      SECOND()       |         返回时间的秒钟部分         |

```sql
SELECT CURRENT_DATE() --> 2020-05-08
SELECT CURRENT_TIME() --> 18:13:21
SELECT CURRENT_TIMESTAMP() --> 2020-05-08 18:13:21
SELECT EXTRACT(YEAR FROM '2020-05-08') --> 2020
SELECT DATE('2020-05-08 18:14:08') --> 2020-05-08
# 对日期比较是推荐先转为date再进行比较 而不是直接进行字符串比较
SELECT * FROM users WHERE DATE(birthdate)>'2016-10-01';
```

- 转化函数

> 转换函数可以转换数据之间的类型，常用的函数如下表所示

|   函数名   |                       定义                       |
| :--------: | :----------------------------------------------: |
|   CAST()   | 数据类型转换，参数是一个表达式：原始数据 AS 类型 |
| COALESCE() |                返回第一个非空数值                |

```sql
SELECT CAST(123.123 AS INT) --> 结果会出错，无法转换
SELECT CAST(123.123 AS DECIMAL(8,2)) --> 123.12
SELECT CAST(NULL AS VARCHAR) --> NULL  可以用来填充虚拟列
SELECT COALESCE(Null,1,2) --> 1
```

- 聚集函数

|  函数   |  说明  |
| :-----: | :----: |
| COUNT() | 总行数 |
|  MAX()  | 最大值 |
|  MIN()  | 最小值 |
|  SUM()  |  求和  |
|  AVG()  | 平均值 |

```sql
SELECT COUNT(*) FROM users;
# COUNT(*)  COUNT(1)  COUNT(列名) 对比
COUNT(*)和COUNT(1)都是对返回的所有数据进行统计 
COUNT(列名)是对返回数据中该列不为NULL的数据统计
COUNT(*)和COUNT(1)本质上没有区别，都是采用全表扫描，循环计数，复杂度O(n)，COUNT(*)略快。
在MyIsam中，会有元数据统计表行数，因此复杂度O(1)，由于InnoDB支持事务，采用行级锁和MVVC，因此无法维护元数据。
在Innodb中，COUNT(*)和COUNT(1)要尽量采用二级索引。因为主键是聚集索引，数据多，二级索引数据量小，统计时Innodb会自动选择最短的二级索引，对于COUNT(列名)，采用主键索引
```

# 数据库优化





### SQL优化

****

**SELECT SQL执行顺序**

> FROM -> WHERE -> GROUP BY -> HAVING -> SELECT查询字段 -> DISTINCT -> ORDER BY -> LIMIT

SELECT语句在执行时，每一步都会产生一个虚拟表，然后将虚拟表传入下一个步骤作为输入，这些过程都是隐式的，对我们不可见。

**具体执行过程如下：**

- 首先执行FROM这一步，如果是单表，直接拿到表作为虚拟表1，如果是多表联结：
  - 首先通过CROSS JOIN求笛卡尔积，得到虚拟表1-1
  - 在虚拟表1的基础上，再通过ON进行筛选，得到虚拟表1-2
  - 如果使用的是左连接，右连接或全连接，就会涉及到外部行，在虚拟表2的基础上增加外部行得到虚拟表1-3
  - 如果操作的是多张表，则反复执行以上步骤，最终得到一张虚拟表
- 拿到查询数据表的原始数据之后，进入WHERE阶段，在虚拟表1的基础上进行筛选得到虚拟表2
- 在虚拟表2的基础上进行分组和分组过滤，得到虚拟表3和虚拟表4
- 在完成筛选过滤之后，在虚拟表4的基础上挑选需要查询的字段，即SELECT的列名，并进行DISTINCT过滤，得到虚拟表5
- 当完成所有过滤并拿到需要的列数据之后，进入ORDER BY阶段，在虚拟表5的基础上根据列名排序，得到虚拟表6
- 排序完成后，在虚拟表6的基础上进行LIMIT限制，得到最终的结果





